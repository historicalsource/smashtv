	.FILE	'TEST.ASM'
	.TITLE	"ROBO TEST PROGRAM"
 	.WIDTH	132
	.OPTION	B,D,L,T
	.MNOLIST
;
;
; COPYRIGHT (C) 1989 WILLIAMS ELECTRONICS GAMES, INC.
;
;
; GET THE SYSTEM STUFF
	
	.INCLUDE	"MPROC.EQU"		;MPROC EQUATES
	.INCLUDE	"DISP.EQU"		;DISPLAY PROC. EQUATES
	.INCLUDE	"\VIDEO\SYS\SYS.INC"	;Z UNIT SYSTEM EQUATES
	.INCLUDE	"\VIDEO\SYS\MACROS.HDR"	;MACROS DEFINITIONS
	.INCLUDE	"IMGTBL.GLO"
	.INCLUDE	"ROBO.EQU"
	.INCLUDE	"LINK.EQU"		;LINKY EQUATES
        .INCLUDE        "MENU.EQU"      	;MENU EQUATES

	.TEXT
*
*       IN THIS MODULE
*
        .DEF         	DIAG,CHK_CMOS
        .DEF         	GEN_MENU,B_MENU
        .DEF         	TOP_BOX,WT_ADV
        .DEF         	WW_ADV
        .DEF         	MAIN_RET,GMENULEV
        .DEF         	CK_DOOR
        .DEF         	AREUSURE
        .DEF         	F_TITLE
        .DEF         	ST_STICK
        .DEF         	GETSTICK
        .DEF         	SUR_MESS
        .DEF         	SURE_BOX
        .DEF         	RT_RET,ROM_RET
        .DEF         	GET_FAC
        .DEF         	MENU_TOP
        .DEF         	CYAN_BOX
        .DEF         	BLNKHELP,H_SLAVE
        .DEF         	DOBORDER
        .DEF         	COL_INST
        .DEF         	STD_BORD
        .DEF         	DIAG_EX
        .DEF         	WAIT_BUT
        .DEF         	DIGSRT
        .DEF         	GET_ADV
        .DEF         	SND_MADE
        .DEF         	NO_CLEAR
        .DEF         	LAST_BUT
        .DEF         	G_BORDER
        .DEF         	FORM_SWS
;	.DEF		LINKY
	.DEF		SW_CHK
	.DEF		COL_BARS		
	.DEF		ROM_CHK
	.DEF		CROSS_H
	.DEF		CPU_CHK
	.DEF		BURN_IN
*
*       IN AUDIT.ASM
*
	.REF         	CMOS_VAL,L_MESS,DISPDUMP
        .REF         	LM_SETUP,LM_FINIS
        .REF         	FORM_ADC
        .REF         	F_ADC_S
        .REF         	GET_AUD
        .REF         	FAC_SET
        .REF         	CRED_P
        .REF         	BAD_AUD
        .REF  		CLR_AUD
        .REF         	ADJ_PAGE
        .REF	 	COIN_PAG
        .REF         	ROM_NAME
*
*        IN HSTD.ASM
*
         .REF         	ALL_TAB,INIT_TB,TOD_TAB
         .REF         	INIT_TAB
         .REF         	E_GAME,VAL_TAB
         .REF         	P_FORK
         .REF         	RC_BYTEI
         .REF         	RC_BYTE
         .REF         	RC_WORD
         .REF         	RC_LONG
         .REF         	RC_LONGI
         .REF         	WC_BYTE
         .REF         	WC_BYTEI
         .REF         	WC_WORD
         .REF         	WC_WORDI
         .REF         	WC_LONG
         .REF         	WC_LONGI
*
*        IN MENU.ASM
*
         .REF         	MEN_MAIN,ANY_BUT,MEN_YN
         .REF         	MESS_FAC
         .REF         	GO_DIAG           ;ROUTINE FOR DIAGNOSTIC MENU
         .REF         	RTR_LEV,ROM_LEV
         .REF         	FAC_STUF
         .REF         	SCODE             ;SYNTH CODE CURRENTLY BEING MADE
         .REF         	DCODE             ;DIG CODE CURRENTLY BEING MADE
*
*        IN ADJUST.ASM
*
         .REF 		DO_ADJH

;
;        IN ROBOATT.ASM
;
	 .REF		WIPEOUT
	 .REF		COLRSTRT

*
*        OTHERS
*
         .REF		WARMSET
         .REF         	QSNDRST
         .REF         	FILLAREA
         .REF         	STRNGLEN

	 .REF		RD15FONT,RD7FONT,STRCNRM,GAMSTATE
	 .REF		IRQSKYE,BLNKAREA,STRLNRM,CLR_SCRN
	 .REF		DMAQWAIT,P1DATA,P2DATA
	 .REF		WDOGDIS
*
*        MAIN_RET
*
*        POSITIVE NUMBER HERE SAYS RETURN (UPWARD) TO MAIN MENU (GEN_MENU ONLY)
*        NEGATIVE NUMBER HERE SAYS SETUP RESTORE AFTER RAM TEST. (GEN_MENU)
*
         .BSS            MAIN_RET,16          ;FLAG SAYS RETURN TO MAIN MENU
         .BSS            GMENULEV,16          ;HOW DEEP INTO GEN_MENU WE ARE
         .BSS            SND_MADE,16          ;SOUND TEST FLAG
         .BSS            NO_CLEAR,16          ;FLAG TELLS GET_MENU NOT TO CLEAR!
         .BSS            LAST_BUT,32
	 .BSS		 SPTEMP,32	      ;STACK POINTER TEMP

         .TEXT


;LINKY:
;
;AMODE:    
;	MOVE    @GAMSTATE,A0,W
;        CMPI    INDIAG,A0
;        JRNZ    DO_AMODE
;        JAUC    SUCIDE
;
;DO_AMODE:
;        MOVI    1,A0
;        MOVE    A0,@DISPLAYON,W      ;TURN DISPLAY SYSTEM ON!
;*
;*        NOW GO INTO ATTRACT MODE
;*
;        MOVI    0,A0                 ;PATCHABLE WAY TO RESET HIGHEST
;        MOVE    A0,A0
;        JRZ     DONT_CLEAR
;
;        MOVI    ALL_TAB,A8           
;        CALLA   INIT_TB
;
;DONT_CLEAR:
;        MOVI    TOD_TAB,A8           ;ALWAYS CLEAR OUT TODAYS TABLE
;        CALLA   INIT_TAB             ;THIS IS THE POWER UP ENTRYPOINT
;
;        MOVI    12345678H,A0         ;GIVE THE "PLAYERS" HIGH SCORES
;        MOVE    A0,@P1DATA+PSCORE,L
;        MOVI    23456789H,A0
;        MOVE    A0,@P2DATA+PSCORE,L
;
;        MOVI    4,A3                 ;START THE RAP!
;        MOVI    3,A5
;        CALLA   SNDSND               ;SEND IT!
;
;        CALLA   CLR_SCRN                  ;CLEAR OUT THE SCREEN
;
;*         A4 = UPPER LEFT Y,X                                           *
;*         A5 = LOWER RIGHT Y,X                                          *
;*         A6 = NUMBER OF SLICES GOING IN.                               *
;
;
;        MOVI    100010H,A4
;        MOVI    6001E0H,A5
;        MOVI    16,A6
;        CALLR   G_BORDER
;
;        JSRP    E_GAME
;*
;*       NOW DISPLAY THE HIGH SCORE TABLE!
;*
;*       LET THE COLOR CYCLERS GO!
;*
;*       THIS IS THE ONLY APPROVED WAY TO SHUT OFF THE 
;*       INTERRUPT DRIVEN SCROLLER!
;*
;DO_HSTD_TABLE:
;;        CALLA   RES_SCRL
;        CLR     A0
;        MOVE    A0,@DISPLAYON,W    ; TURN OFF DMA
;        CALLA   DMAQWAIT           ; WAIT FOR DMA TO BE DONE (IF IN MOTION)
;;        JSRP    HSTDTAB
;        JRUC    AMODE

**************************************************************************
*                                                                        *
*          RT_RET                                                        *
*                                                                        *
*          THIS IS THE RETURN POINT FROM THE RAM TEST.                   *
*                                                                        *
*          SINCE RAM TEST SMASHES RAM, THE MENU "JSRP"                   *
*          GEN_MENU TREE HAS BEEN SMASHED.  				 *
*          THIS PROCESS IS CALLED AFTER RAM TEST WHICH MUST GET THE      *          *
*          "MONITOR PATTERN" PART OF THE DIAGNOSTIC TEST                 *
*          UP TO BE SELECTED.                                            *
*                                                                        *
**************************************************************************
RT_RET:   
	CALLR   DIAG_STATE      ;GET THE STATE RIGHT.....BUT DON'T MESS UP TILL BUTTON
        JSRP    WAIT_BUT        ;NOW WAIT FOR ANY BUTTON.
        CALLR   DIGSRT          ;MAKE SURE WE'RE IN TEST MODE

        CLR     A0
        MOVE    A0,@GMENULEV,W  ;INDICATE WE'RE AT LEVEL ZERO.

        MOVI    RTR_LEV,A0      ;THIS IS THE LEVEL TO DIVE TO
        NEG     A0              ;NEGATE IT AS FLAG TO DIVE.
        MOVE    A0,@MAIN_RET,W  ;INDICATE
        JAUC    DIAG_RESTART    ;NOW START IT UP....

**************************************************************************
*                                                                        *
*          ROM_RET                                                       *
*                                                                        *
*          THIS IS RETURN FROM ROM TEST.   SINCE WE NEED TO TEST         *
*          RAM BEFORE ROM, OUR STATE IS ALSO SMASHED FROM ROM TEST.      *
*                                                                        *
**************************************************************************
ROM_RET:  
	CALLR   DIAG_STATE      ;GET THE STATE RIGHT.....BUT DON'T MESS UP TILL BUTTON
        JSRP    WAIT_BUT        ;NOW WAIT FOR ANY BUTTON.
        CALLR   DIGSRT          ;MAKE SURE WE'RE IN TEST MODE

        CLR     A0
        MOVE    A0,@GMENULEV,W  ;INDICATE WE'RE AT LEVEL ZERO.

        MOVI    ROM_LEV,A0      ;THIS IS THE LEVEL TO DIVE TO
        NEG     A0              ;NEGATE IT AS FLAG TO DIVE.
        MOVE    A0,@MAIN_RET,W  ;INDICATE
        JAUC    DIAG_RESTART    ;NOW START IT UP....

**************************************************************************
*                                                                        *
*          WAIT_BUT                                                      *
*                                                                        *
*          THIS IS CALLED ON RETURN FROM MANY OF THE "HARD"              *
*          DIAGNOSTIC TESTS TO HOLD CONTROL TILL ANY BUTTON IS           *
*          HIT.                                                          *
*                                                                        *
**************************************************************************
WAIT_BUT:
        CALLR   FORM_SWS        ;1ST STATE DOESN'T COUNT
*
*       RETURN CURRENT STATE IN A0..PREVIOUS STATE IN A1.
*
WB1:      
	SLEEP   1
        CALLR   FORM_SWS
        NOT     A1                   ;LAST = 0 AND NOW = 1 MEANS EDGE!

        AND     A1,A0                ;1'S WHERE WE HAVE POSITIVE EDGE.
        ANDI    BUTTONS,A0           ;IS IT A BUTTON? 
        JRZ     WB1
        SOUND1  BEEP_1                ;MAKE A BEEP
        RETP

**************************************************************************
*                                                                        *
*          DIAG                                                          *
*                                                                        *
*          THIS IS THE ENTRY TO THE MAIN DIAGNOSTIC MENU.                *
*                                                                        *
**************************************************************************
DIAG:     
	MOVE	@GAMSTATE,A0,W
	CMPI	INDIAG,A0
	JRNZ	DIAG_JUMP
	JAUC	SUCIDE

DIAG_JUMP:
        CALLR   DIGSRT          ;MAKE SURE WE'RE IN TEST MODE
        JSRP    WW_ADV          ;HOLD UNTIL HE LETS GO!

        CLR     A0
        MOVE    A0,@MAIN_RET,W  ;CLEAR THE FLOAT TO TOP FLAG.
        MOVE    A0,@GMENULEV,W  ;INDICATE WE'RE AT LEVEL ZERO.

DIAG_RESTART:
        MOVI    MEN_MAIN,A8
        JSRP    GEN_MENU             ;PROCESS THIS MENU!
*
*       HE (FINALLY) PICKED EXIT....RETURN!
*
DIAG_EX:
        SLEEP   2                     ;LET DMA EMPTY OUT IF NECESSARY

        CALLA   CMOS_VAL  	      ;IF SETTINGS SMASHED....FIX EM.   
;        JANZ    SETUP                                                 
                                                                       
	JAUC	WARMSET		      

**************************************************************************
*                                                                        *
*          GEN_MENU                                                      *
*                                                                        *
*          THIS IS A GENERAL MENU HANDLER.  IT POSTS THE MENU            *
*          WITH SELECTION 1 AVAILABLE.  AFTER A SELECTION IS             *
*          MADE, IF IT HAS A ROUTINE CODE OF ZERO, (EXIT)                *
*          IT RETURNS TO THE LEVEL ABOVE IT.  ELSE, IT                   *
*          JSRP'S THE NEW ROUTINE.  WHEN THE NEW ROUTINE                 *
*          RETURNS, WE RE-POST THE SAME MENU WITH THE                    *
*          BAR ON THE FOLLOWING ENTRY.                                   *
*                                                                        *
*          A8 = MENU DESCRIPTOR                                          *
*                                                                        *
**************************************************************************
*
*        MENU ROM OFFSETS
*
MR_FONT   EQU     0
MR_TCAL   EQU     MR_FONT+LONG_SIZE
MR_TITLE  EQU     MR_TCAL+LONG_SIZE    ;POINTER TO TITLE FOR TILE BOX (IF NEC)
MR_TCLR   EQU     MR_TITLE+LONG_SIZE   ;COLOR OF TITLE
MR_WORDS  EQU     MR_TCLR+WORD_SIZE    ;STREAM OF WORDS TO COPY TO PDATA STARTS HERE
MR_X      EQU     MR_WORDS
MR_Y      EQU     MR_X+WORD_SIZE
MR_DY     EQU     MR_Y+WORD_SIZE
MR_COL    EQU     MR_DY+WORD_SIZE
MR_HITE   EQU     MR_COL+WORD_SIZE
MR_BDY    EQU     MR_HITE+WORD_SIZE
MR_DX     EQU     MR_BDY+WORD_SIZE
MR_WID    EQU     MR_DX+WORD_SIZE
	
GEN_MENU:
        MOVE    @GMENULEV,A0,W            ;KICK LEVEL POINTER
        INC     A0
        MOVE    A0,@GMENULEV,W
*
        MOVE    A8,-*A12,L                ;SAVE MENU PTR
        MOVI    1,A8                      ;START WITH "FIRST" ENTRY
        MOVE    A8,-*A12,W                ;PUT MENU NUMBER AS A WORD
*
*       IF WE GET HERE AND MAIN_RET IS NOT ZERO, THE WE MUST
*       RETURN TO LEVEL ABOVE US IF WE'RE NOT THE MAIN
*       MENU.
*

GEN_LOOP: 
	MOVE    @MAIN_RET,A0,W            ;ARE WE IN "EXIT" MODE?
        JRZ     NO_EXIT                   ;NO

        JRN     DIVE_TO_MONITOR           ;WE'RE DIVING TO MONITOR PATTERNS.

        MOVE    @GMENULEV,A0,W            ;CHECK LEVEL
        CMPI    1,A0                      ;ARE WE AT LEVEL 1
        JRNZ    GEN_EXIT                  ;NOPE.....POP UP A LEVEL.
*
*       WE'RE AT LEVEL 1....CLEAR OUT THE FLAG THAT
*       GOT US HERE.
*
DIVE_COMPLETE:
        CLR     A0
        MOVE    A0,@MAIN_RET,W            ;NOW WE MAY PROCEED!

NO_EXIT:  
	MOVE    @NO_CLEAR,A0,W            ;INHIBIT CLEAR?
        JRNZ    SKIP_CLR

        CALLA   CLR_SCRN                  ;CLEAR THE SCREEN

SKIP_CLR: 
	CLR     A0
        MOVE    A0,@NO_CLEAR,W            ;AND RE-SET IT!

        MOVE    *A12(WORD_SIZE),A8,L      ;GET MENU DESCRIPTOR
        JSRP    MENU_TOP
        JSRP    CYAN_BOX                  ;PUT UP MAIN MENU INSTRUCTIONS

        MOVE    *A12,A9,W                 ;GET MENU NUMBER TO USE
        JSRP    B_MENU                    ;GET RESULT

PHONEY_MENU_RET:

        MOVE    A10,A10                   ;WAS IT ADVANCE?
        JRZ     NO_KICK                   ;NOPE....LEAVE WHERE HE CAME FROM

        INC     A8                        ;KICK INDEX BY 1 FOR NEXT TIME
NO_KICK:  
	MOVE    A8,*A12,W                 ;AND LEAVE ON THE STACK

        MOVE    A9,A9                     ;NOW JSRP THE ROUTINE
        JRZ     GEN_EXIT                  ;NONE THERE....ITS "EXIT"
*
*       JSRP TO A9
*
        MOVI    GEN_LOOP,A7
	MOVE	A7,-*A12,L	;PUSH RET ADDR
	JUMP	A9

GEN_EXIT: 
	ADDI    WORD_SIZE+LONG_SIZE,A12   ;POP THE ARGUMENTS
        MOVE    @GMENULEV,A0,W            ;KICK LEVEL POINTER
        DEC     A0
        MOVE    A0,@GMENULEV,W
        RETP

**************************************************************************
*                                                                        *
*          DIVE_TO_MONITOR                                               *
*                                                                        *
*          WE GET CONTROL HERE WHEN WE ARE KLUDGING THE RETURN           *
*          FROM "CPU" TEST (WHICH BLOWS AWAY RAM!)                       *
*                                                                        *
**************************************************************************
DIVE_TO_MONITOR:
        MOVE    @GMENULEV,A0,W            ;CHECK LEVEL
        CMPI    1,A0                      ;ARE WE AT LEVEL 1
        JRNZ    DTM1                      ;NOPE....SET "MONITOR" LEVEL
*
*       WE'RE AT LEVEL 1......."SELECT" THE DIAGNOSTIC MENU
*       A8 = 1.....A9 = ROUTINE FOR DIAGNOSTIC MENU
*
        MOVK    1,A8
        MOVI    GO_DIAG,A9           ;ROUTINE FOR DIAGNOSTIC MENU
        MOVK    1,A10                ;RETURN AS IF ADVANCE WAS PRESSED
        JRUC    PHONEY_MENU_RET      ;WE'RE READY TO CALL DIAG MENU
*
*       WE'RE IN DIAGNOSTIC MENU....NOW WE JUST NEED TO MAKE
*       THE "CURRENT" SELECTION THE ONE AFTER CPU TEST
*       (MONITOR PATTERNS)
*
DTM1:    
	MOVE    @MAIN_RET,A8,W            ;FLAG IS OPPOSITE OF ENTRY NUMBER
        NEG     A8                        ;THIS IS RETURN LEVEL!
*        MOVI    RTR_LEV,A8                ;START WITH "RETURN" ENTRY NUMBER
        MOVE    A8,*A12,W                 ;PUT MENU NUMBER AS A WORD
        JRUC    DIVE_COMPLETE             ;THIS COMPLETES THE DIVE!

**************************************************************************
*
*          FOR DOBORDER
*
*          A4 = UPPER LEFT Y,X                                           
*          A5 = LOWER RIGHT Y,X                                        
*          A0 = Y,X WIDTH OF BORDER                                     
*          A9 = COLOR OF BORDER.                                         

**************************************************************************
*                                                                        *
*          TOP_BOX                                                       *
*                                                                        *
*          THIS DISPLAYS THE TEST BOX AT THE TOP.                        *
*                                                                        *
*          A2 POINTS AT THE STRING TO CENTER IN THE BOX.                 *
*          A3 IS COLOR TO DO IT IN.                                      *
*                                                                        *
**************************************************************************
MENU_TOP: 
	MOVE    *A8(MR_TITLE),A2,L        ;GET TITLE INTO A2
        MOVE    *A8(MR_TCLR),A3,W         ;AND COLOR INTO A3

TOP_BOX:
        MOVE    A8,-*A12,L                ;PUSH MENU PTR
*
*       FIRST MAKE THE BOX...IT BLACKS OUT THE REGION
*
        CALLR   SCR_BOX                        ;PUT UP THE TITLE BOX

        MOVI    MESS_TITLE,A8    ;SET PARAMETERS
        CALLA   LM_SETUP         ;PUT IT OUT.

        MOVE    A2,A8            ;GET STRING IN THE CORRECT REGGIE
        MOVE    A3,A6            ;MOVE COLOR TO COLOR REGGIE
*
        JSRP    LM_FINIS         ;AND PRINT IT!

        JSRP    SCR_REV          ;NOW ADD THE REV.

        MOVE    *A12+,A8,L       ;RESTORE THE MENU PTR

        RETP

**************************************************************************
*                                                                        *
*          SCR_REV                                                       *
*                                                                        *
*          DISPLAY REV IN TITLE BOX.                                     *
*                                                                        *
**************************************************************************
SCR_REV:
        MOVI    MESS_REV,A8     ;GET READY FOR REV MESSAGE
        CALLA   LM_SETUP        ;SETUP FOR REV MESSAGE

        MOVI    ROM_NAME,A8     ;USE ROM COPY OF REV.
        JSRP    LM_FINIS        ;FINISH PRINTING MESSAGE
        RETP

**************************************************************************
*                                                                        *
*          SCR_BOX                                                       *
*                                                                        *
*          THIS DISPLAYS THE TITLE BOX.                                  *
*                                                                        *
**************************************************************************
SCR_BOX:
        MOVI    TIT_ULX+(10000H*TIT_ULY),A4    ;UPPER LEFT
        MOVI    TIT_LRX+(10000H*TIT_LRY),A5    ;UPPER LEFT
        MOVI    ROBO_ORANGE,A9
        CALLR   STD_BORD       
        RETS
*
*        THIS PRINTS THE "MOVE JOYSTICK" BOX.
*
*        A8 = MENU DESCRIPTOR THAT WILL ACCOMPANY IT
*        ON SCREEN.  WE ADJUST THE BOX EDGES AND
*        MESSAGE CENTER IN "X" ONLY TO CORRESPOND
*        TO THE MENU BOX.
*
CYAN_BOX:
        MOVE    A8,-*A12,L                       ;PUSH THE MENU PTR

        MOVI    ROBO_CYAN,A9
        CALLR   COL_INST             ;THIS PRINTS BOX AND STASHES 
*                                     ;CENTER X AT *A13(PDATA),W

        MOVI    MM_INST1,A8     ;POINT AT INSTRUCTIONS MESSAGE
        JSRP    C_PD_M

        MOVI    MM_INST2,A8     ;POINT AT INSTRUCTIONS MESSAGE
        JSRP    C_PD_M

        MOVE    *A12+,A8,L      ;GET BACK MENU PTR.
        RETP

**************************************************************************
*                                                                        *
*          COL_INST                                                      *
*                                                                        *
*          THIS PRINTS OUT THE "CYAN" INSTRUCTION BOX                    *
*          IN THE COLOR SPECIFIED BY A9.                                 *
*                                                                        *
**************************************************************************
COL_INST:
*
*       WE NEED TO DETERMINE LEFT AND RIGHT X
*
        CALLR   STUFF_MENU_PROCESS               ;MOVE DATA INTO PDATA AREA
        CALLR   MEN_NUMS                         ;GET THE NUMBERS FOR THIS MENU
        MOVE    A6,*A13(PDATA),W                 ;STASH THE X CENTER
        ADDI    10000H*INST_ULY,A4               ;UPPER LEFT Y
        ADDI    10000H*INST_LRY,A5               ;UPPER LEFT X
        CALLR   STD_BORD       
        RETS

**************************************************************************
*                                                                        *
*          MEN_NUMS                                                      *
*                                                                        *
*          THIS IS CALLED TO GET SOME NUMBERS ASSOCIATED                 *
*          WITH A MENU BOX.                                              *
*                                                                        *
*          THIS RETURNS:                                                 *
*                                                                        *
*          A4 = LEFT X                                                   *
*          A5 = RIGHT X                                                  *
*          A6 = CENTER X                                                 *
*                                                                        *
**************************************************************************
MEN_NUMS:
        CALLR   MENU_UL_A4_A5                    ;LEFT X IN A4
        CALLR   MENU_LR_A6_A5                    ;RIGHT X IN A6
        MOVE    A6,A5                            ;COPY RIGHT X INTO A5
        ADD     A4,A6                            ;FIND CENTER
        SRL     1,A6                             ;A6 NOW HAS CENTER X (FOR LATER)
        RETS

**************************************************************************
*                                                                        *
*          C_PD_M                                                        *
*                                                                        *
*          THIS PRINTS A L_MESS MESSAGE PASSED IN A8, CENTERED           *
*          ON THE X STORED AT *A13(PDATA),W                              *
*                                                                        *
**************************************************************************
C_PD_M:
        CALLA   LM_SETUP        ;SETUP THE MESSAGE
        ANDI    0FFFF0000H,A9   ;REMOVE X
        MOVE    *A13(PDATA),A3,W     ;GET THE X
        ADD     A3,A9                ;PUT OUR X IN
        JUMP    A1                   ;AND "CALL" THE ROUTINE

**************************************************************************
*                                                                        *
*          DIGSRT                                                        *
*                                                                        *
*          THIS IS CALLED ON ENTRY TO DIAGNOSTICS.                       *
*                                                                        *
**************************************************************************

DIGSRT:   
	CALLR   DIAG_STATE
        CALLA   WIPEOUT         ;INITIALIZE THE OBJECT LIST
        CALLA   COLRSTRT        ;RESTART THE COLOR PROCESSES.
	CALLA   QSNDRST	        ;kill any sounds in progress
        MOVK	1,A0
	MOVE	A0,@DISPLAYON,W	 ;WE NEED TO SEE THE STUFF JACK
        CALLA   CLR_SCRN        ;CLEAR THE SCREEN!
        RETS

DIAG_STATE: 
        CLR     A1
        CALLA   KILALL          ;KILL ABSOLUTELY EVERYONE!

        MOVI    DIAG_PID,A1          ;SET OUR ID TO DIAGNOSTICS MAN
        MOVE    A1,*A13(PROCID),W    ;PASS OUR ID TO FORKED PROCESS

        MOVI    INDIAG,A0
        MOVE    A0,@GAMSTATE,W  ;PUT US IN TEST MODE!
        RETS

**************************************************************************
*                                                                        *
*          CHK_CMOS                                                      *
*                                                                        *
*          This is the routine that is called at power up.               *
*                                                                        *
*          It checks to see if CMOS adjustments are in tact.             *
*          IF THE ADJUSTMENTS ARE BAD, OR SET FOR A DIFFERENT            *
*          GAME OR REVISION, we cause a factory setting to               *
*          occur.  We then try and validate the all time                 *
*          HSTD table.  If this is bad we then zero audits.              *
*          If HSTD table is ok, then we leave audits alone.              *
*                                                                        *
**************************************************************************
CHK_CMOS:
	CALLR   DIGSRT      ;CLEAR OUT THE SCREEN...(MESSAGE WILL FOLLOW!)
        CALLA   CMOS_VAL
        JRNZ    FAC_TIME
	MOVI    MESS_BITCHIN,A2          ;POINT AT DATA
        MOVI    ROBO_WHITE,A3
        JSRP    TOP_BOX
        SLEEP	 18H

        JAUC	 WARMSET              ;CMOS IS OK....RETURN!
*
*       WE NEED TO FACTORY SET THIS THING (DUE TO BAD SETTINGS.)
*
FAC_TIME: 
	JSRP    GET_FAC                   ;GET THE GAME TO FACTORY SETTINGS!
        JSRP    WW_ADV                    ;WAIT WHILE ADVANCE IS PRESSED

        JSRP    WT_ADV                    ;NOW WAIT TILL ADVANCE IS PRESSED

        CALLA   CLR_SCRN                  ;PRESSED....BLANK THE SCREEN AND
                                           ;HOLD TILL HE LETS GO.

        JSRP    WW_ADV                    ;HOLD CONTROL HERE TILL HE LETS GO
        JRUC    DIAG_JUMP                 ;NOW INTO TEST MODE FOR ADV. BUTTON.

**************************************************************************
*                                                                        *
*          GET_FAC                                                       *
*                                                                        *
*          THIS IS CALLED TO BRING THE GAME TO A FACTORY SETTINGS        *
*          STATE.  IT WILL STORE THE FACTORY SETTINGS OR WAIT            *
*          UNTIL THE DOOR IS OPEN.  IF IT CAN'T GET FACTORY SETTINGS     *
*          IT WILL PRINT A FAILURE MESSAGE.                              *
*                                                                        *
**************************************************************************
GET_FAC:
*
FAC_LOOP:
        CALLA   CLR_SCRN             ;CLEAR SCREEN IN ANTICIPATION OF MESSAGE
        CALLA   FAC_SET              ;THIS DOES THE DEED!
        CALLA   CMOS_VAL            ;IS IT OK NOW?
        JRZ     CMOS_FIXED           ;YEP....FINISH CLEANUP!
*
*       DIDN'T WORK.....CHECK DOOR AND GIVE 1 OF 2 MESSAGES!
*
        CALLR   CK_DOOR       ;IS THE DOOR OPEN?  NZ=OPEN
        JRNZ    CANT_SET             ;YEP.......PRINT FAILURE MESSAGE

WAIT_FOR_DOOR:
        MOVI    MESS_DOOR,A8          ;POINT AT DATA
        JSRP    L_MESS               ;DISPLAY LARRY MESSAGE

        SLEEP   10H
        CALLR   CK_DOOR
        JRNZ    FAC_LOOP

        MOVI    MESS_OPEN,A8
        CALLA   LM_SETUP             ;SETUP REG'S

        CLR     A6                   ;BUT USE BLACK!
        JSRP    LM_FINIS            ;NOW PRINT THE STRING

        MOVI    MESS_OPEN_2,A8
        CALLA   LM_SETUP

        CLR     A6
        JSRP    LM_FINIS

        SLEEP   10H
        CALLR   CK_DOOR
        JRNZ    FAC_LOOP

        JRUC    WAIT_FOR_DOOR             ;ITS OPEN......DO THE WORK.
*
*       WASN'T ABLE FO FACTORY SET IT.....DOOR IS NOT LOCKING
*       IT OUT....1 MORE TRY, THEN CALL IT A DAY.
*
CANT_SET:
        CALLA   FAC_SET              ;THIS DOES THE DEED!
        CALLA   CMOS_VAL            ;IS IT OK NOW?
        JRZ     CMOS_FIXED           ;YEP....FINISH CLEANUP!

        MOVI    MESS_FAIL,A8         ;POINT AT DATA
        JSRP    L_MESS               ;DISPLAY LARRY MESSAGE

        JRUC    WAIT_POINT           ;WE'RE DEAD.....ADVANCE TAKES US TO TEST MODE!

CMOS_FIXED:
*
*       THIS IS WHERE WE ARE ONCE WE HAVE FACTORY SET....
*       MESSAGE WOULD GO HERE.
*
        CALLR   CENT_BOX             ;PUT A BOX AROUND IT
*
        MOVI    MESS_FAC,A8          ;POINT AT DATA
        JSRP    L_MESS               ;DISPLAY LARRY MESSAGE
*
*       NOW.....CLEAR HIGH SCORE TABLE
*       CLEAR OUT THE AUDITS.
*
        CALLA   FAC_STUF             ;DO REST OF FULL FACTORY STUFF!
*
*       AT THIS POINT WE HANG WAITING FOR THE ADVANCE SWITCH.
*
WAIT_POINT:
        RETP                              ;NOW LET CALLER TAKE OVER.

**************************************************************************
*                                                                        *
*          WT_ADV                                                        *
*                                                                        *
*          WAIT TILL ADVANCE.  THIS HOLDS CONTROL UNTIL ADVANCE          *
*          BUTTON IS PRESSED.                                            *
*                                                                        *
**************************************************************************
WT_ADV:   
	SLEEP   2

WT_A6:    
	CALLR   GET_ADV               ;SCAN THE BUTTON
        JRNZ    WT_ADV                ;NOT PRESSED. 
        RETP

COINSND	.WORD	>F3DF,>10,>8085,0		;"COIN" SOUND
BEEP_1   .WORD	>F3DF,>10,>80A2,0		;LOW BEEP 
BEEP_2   .WORD	>F3DF,>10,>80A3,0		
BEEP_3   .WORD	>F3DF,>10,>80A4,0		
BEEP_4   .WORD	>F3DF,>10,>80A5,0		;HIGH BEEP

**************************************************************************
*                                                                        *
*          WW_ADV                                                        *
*                                                                        *
*          WAIT WHILE ADVANCE.  THIS HOLDS CONTROL WHILE ADVANCE         *
*          BUTTON IS HELD (OR STUCK).                                    *
*                                                                        *
**************************************************************************
WW_ADV:   
	SLEEP   2
        CALLR   GET_ADV
        JRZ     WW_ADV
        RETP

**************************************************************************
*                                                                        *
*          GET_ADV                                                       *
*                                                                        *
*          THIS GETS PHYSICAL STATE OF ADVANCE BUTTON.                   *
*                                                                        *
*          .EQ.    PRESSED                                               *
*          .NE.    OPEN                                                  *
*                                                                        *
**************************************************************************
GET_ADV:
        MMTM    SP,A0
        MOVE    @COINS,A0,W               ;FETCH COIN SWITCHES (LOOKING FOR ADVANCE)
        ANDI    ADV_BIT,A0                ;KEEP ADVANCE BIT.
	MMFM    SP,A0
	RETS

**************************************************************************
*                                                                        *
*          CK_DOOR                                                *
*                                                                        *
*          THIS IS CALLED TO SEE IF THE FRONT DOOR (MEMORY               *
*          PROTECT SWITCH IS OPEN.                                       *
*                                                                        *
*          .NE.    OPEN  (OK TO WRITE CMOS)                              *
*          .EQ.    CLOSED (CAN'T WRITE CMOS)                             *
*                                                                        *
**************************************************************************
CK_DOOR:
        MMTM    SP,A0
        MOVE    @COINS,A0,W               ;FETCH COIN SWITCHES (LOOKING FOR ADVANCE)
        ANDI    DOOR_BIT,A0               ;KEEP COIN DOOR MEMORY PROTECT.
	MMFM    SP,A0
	RETS

**************************************************************************
*                                                                        *
*          GET_MENU                                                      *
*                                                                        *
*          This routine is called (via JSRP) to display a menu on        *
*          screen and receive a selection from the operator.             *
*                                                                        *
*          The menu descriptor is passed in A8.                          *
*                                                                        *
*          The selection number is returned in a8. (line 1 = 1)          *
*          The routine address is returned in a9.                        *
*          A10 is returned non-zero if advance was the button used       *
*                                                                        *
*          A menu (pointed to by A8) is defined as follows:              *
*                                                                        *
*                      FONT TO BE USED             (LONG)                *
*                      X FOR LEFT MARGIN           (WORD)                *
*                      Y FOR TOP LINE              (WORD)                *
*                      DY PER ENTRY                (WORD)                *
*                      TEXT_COLOR                  (WORD)                *
*                      HEIGHT OF SELECTION BAR     (WORD)                *
*                      DX FROM TOP OF TEXT TO SEL. BAR  (WORD)           *
*                                                                        *
*          A9 POINTS AT ENTRY TO START WITH                              *
*                                                                        *
*          Then for each entry:                                          *
*                                                                        *
*                      TEXT POINTER        (LONG)                        *
*                      ACTIVATION ROUTINE  (LONG)                        *
*                                                                        *
*          The list is terminated by a zero.                             *
*                                                                        *
*          This routine forks a separate process to do the work          *
*          for it.  Therefore the caller has full use of                 *
*          the PDATA area.                                               *
*                                                                        *
**************************************************************************
*
*        Equates for GET_MENU slave process.
*
MEN_OFF   EQU     PDATA                ;WORD-OFFSET INTO MENU OF SELECTION
MEN_ROUT  EQU     MEN_OFF+WORD_SIZE    ;LONG-ROUTINE FOR SELECTION
MEN_ROM   EQU     MEN_ROUT+LONG_SIZE   ;LONG-POINTER TO ROM STRUCTURE
MEN_ULX   EQU     MEN_ROM+LONG_SIZE    ;WORD-LEFT X  (CENTER X WHEN CENTERING)
MEN_ULY   EQU     MEN_ULX+WORD_SIZE    ;WORD-TOP Y
MEN_DY    EQU     MEN_ULY+WORD_SIZE    ;WORD-Y UNITS PER ENTRY
MEN_COLR  EQU     MEN_DY+WORD_SIZE     ;WORD-COLOR FOR ENTRIES
MEN_BAR   EQU     MEN_COLR+WORD_SIZE   ;WORD-HEIGHT OF SELECTION BAR
MEN_BDY   EQU     MEN_BAR+WORD_SIZE    ;WORD-DY FROM TOP OF TEXT TO TOP OF BAR.
MEN_BDX   EQU     MEN_BDY+WORD_SIZE    ;WORD-DX FROM LEFT OF WORD TO LEFT OF BAR
MEN_BWID  EQU     MEN_BDX+WORD_SIZE    ;WORD-WIDTH OF BAR
MEN_SCOL  EQU     MEN_BWID+WORD_SIZE   ;WORD-COLOR OF SELECTED TEXT
MEN_TPTR  EQU     MEN_SCOL+WORD_SIZE    ;LONG-POINTER TO BEGINNING OF TEXT ENTRIES.
MEN_ENTS  EQU     MEN_TPTR+LONG_SIZE   ;WORD-NUMBER OF ENTRIES IN MENU
MEN_CUR   EQU     MEN_ENTS+WORD_SIZE   ;WORD-CURRENT SELECTION (1ST IS 1)
MEN_WALK  EQU     MEN_CUR+WORD_SIZE    ;WORD-NUMBER OF ENTRY WE'RE ON AS WE WALK
MEN_STIK  EQU     MEN_WALK+WORD_SIZE   ;LONG-"STUCK" STATE OF SWITCHES
MEN_ACT   EQU     MEN_STIK+LONG_SIZE   ;LONG-SWITCH WE'RE ACTING ON. (BIT)
MEN_TYPO  EQU     MEN_ACT+LONG_SIZE    ;WORD-TYPOMATIC COUNTER
MEN_HITS  EQU     MEN_TYPO+WORD_SIZE   ;WORD-CONSECUTIVE TYPOMATIC HITS
MEN_ADV   EQU     MEN_HITS+WORD_SIZE   ;WORD-NON-ZERO IF ADVANCE WAS BUTTON USED

WORD_ENTS    EQU    (MEN_TPTR-MEN_ULX)/WORD_SIZE   ;NUMBER OF WORD ENTRIES

B_MENU:   
	MOVI    BD_SLAVE,A7
        JRUC    GMJMP

GET_MENU:
        MOVI    GM_SLAVE,A7          ;THIS IS ROUTINE
GMJMP:
        MOVI    MENU_PID,A1          ;THIS IS ID
        CALLA   GETPRC               ;CREATE IT

        MOVE    A0,A10               ;SAVE HIS POINTER

GM1:      
	SLEEP   2

        MOVI    MDUN_PID,A0
        MOVI    0FFFFH,A1
        CALLA   EXISTP               ;WAIT FOR ID TO CHANGE TO THIS!

        JRZ     GM1                  ;LOOP UNTIL IT EXISTS!

        MOVE    *A10(MEN_OFF),A8,W   ;RETURN OFFSET OF SELECTION
        MOVE    *A10(MEN_ROUT),A9,L  ;AND ROUTINE THAT WAS SELECTED.
        MOVE    *A10(MEN_ADV),A10,W  ;INDICATE WHETHER ADVANCE WAS USED

        MOVI    MDUN_PID,A0
        MOVI    0FFFFH,A1
        CALLA   KILALL               ;KILL THE HANGING MENU GETTER!
        RETP                         ;AND RETURN
         
**************************************************************************
*                                                                        *
*          GM_SLAVE                                                      *
*                                                                        *
*          This displays the menu.......moves the selection bar          *
*          and returns the selection information by stuffing             *
*          it in its process area and changing its ID to                 *
*          MDUN_PID once selection is made.                              *
*                                                                        *
*          On entry....A8 points at the GET_MENU data structure.         *
*                      A9 is which entry to start with selected.         *
*                                                                        *
**************************************************************************
BD_SLAVE: 
	CALLR   MENU_BORDER          ;DRAW THE BORDER FOR SELCTIONS.

GM_SLAVE: 
	JSRP    ST_STICK          ;TELL STICK(S) AND BUTTONS WE'RE STARTING.

        CALLR   STUFF_MENU_PROCESS   ;MOVE DATA INTO PDATA AREA
*
*       PLOT ENTIRE MENU
*
*       DO_MENU_LINE WILL RETURN CARRY SET
*       WHEN WE GET BEYOND THE END.
*
        MOVK    1,A0                        ;SETUP FOR LINE 1.
*
DO_ANOTHER_LINE:
;
        MOVE    A0,*A13(MEN_WALK),W       ;WALK THROUGH.

        JSRP    DO_MENU_LINE              ;PUT OUT LINE IN A0.
        MOVE    *A13(MEN_WALK),A0,W       ;GET BACK THE COUNTER

        INC     A0                        ;MOVE TO NEXT ENTRY.
        MOVE    *A13(MEN_ENTS),A1,W       ;SEE IF WE'RE DONE.
        CMP     A1,A0
        JRLS    DO_ANOTHER_LINE
*
*       MAIN MENU PLOTTED......NOW LET THE DMA UN-LOAD BEFORE PLOTTING HELP
*
        CALLR   PLOT_HELP                 ;PLOT HELP FOR 1ST IF NECESSARY

*        SLEEP   2                         ;NOW MAKE SURE THE HELP GETS PLOTTED
*
*       NOW WE JUST WANT TO UPDATE BASED ON STICK...ACT
*       ON BUTTONS!
*
*       RESPONSES:   UP....DOWN....BUTTON....NOTHING....
*
*       NOTHING = 0
*       UP = 1
*       DOWN = 2
*       BUTTON = 3
*
*       A0 = RESPONSE
*       A1 = MEN_CUR VALUE.
*
MENU_LOOP:
        SLEEP   1
        MOVI    MENU_TYPO,A5
        JSRP    GETSTICK                 ;ASK THE STICK HANDLER.......
        MOVE    A0,A0                     ;SEE WHAT GET_STICK RETURNED.
        JRZ     MENU_LOOP                 ;MENU...(PAUSE)        NOTHING.

        MOVE    *A13(MEN_CUR),A1,W        ;GET CURRENT ENTRY...IN A1

        CMPI    3,A0                      ;BUTTON?
        JRZ     MENU_BUTTON               ;YEP....WE'RE OUT OF HERE.

        CMPI    2,A0
        JRZ     MENU_DOWN                 ;ITS DOWN....
*
*       REQUEST TO GO UP....ARE WE AT #1
*
        CMPI    1,A1                      ;WELL?
        JRLS    MENU_LOOP                 ;YEP....IGNORE

        JSRP    UN_SELECT                 ;PUT BACK THE OLD "CURRENT ONE
        MOVE    *A13(MEN_CUR),A0,W        ;GET CURRENT ENTRY
        DEC     A0                        ;MAKE ONE LESS.
        JRUC    JOIN_DOWN                 ;NOW PLOT THE NEW ONE.

MENU_DOWN:
        MOVE    *A13(MEN_ENTS),A2,W       ;GET NUMBER IN MENU
        CMP     A2,A1                     ;ARE WE AT MAX
        JRHS    MENU_LOOP                 ;YEP...NO ACTION

        JSRP    UN_SELECT                 ;PUT BACK THE OLD "CURRENT ONE

        MOVE    *A13(MEN_CUR),A0,W        ;GET CURRENT ENTRY
        INC     A0                        ;MAKE THIS THE NEXT.

JOIN_DOWN:
        MOVE    A0,*A13(MEN_CUR),W        ;PUT BACK
        JSRP    DO_MENU_LINE              ;PUT OUT LINE IN A0.
*
*       MAKE THE "DINK" SOUND HERE FOR ENTRY TO ENTRY MOVEMENT 
*
        CALLR   PLOT_HELP                 ;PLOT HELP NEW ONE
        SLEEP   1                         ;DELAY BEEP 1 FRAME
        SOUND1  BEEP_1                    ;MAKE A BEEP.
        JRUC    MENU_LOOP                 ;AND WAIT FOR NEXT RESPONSE.
*
*       CONTROL COMES HERE WHEN A BUTTON IS PRESSED
*
*         The selection number is returned in a8. (line 1 = 1)          
*         The routine address is returned in a9.                        

MENU_BUTTON:
*
*       A0 HAS A 3.
*       A2 HAS THE BUTTON BIT.....IS IT ADVANCE?
*
        CMPI    ADV_HIGH,A2               ;WAS IT ADVANCE?
        JRZ     IS_ADV                    ;YEP....USE THE 3
        CLR     A0                        ;NOT ADVANCE

IS_ADV:   
	MOVE    A0,*A13(MEN_ADV),W        ;NON ZERO IF IT WAS ADVANCE

        JSRP    BUTTON_STALL              ;HIGHLIGHT SELECTION AND HANG ON BUTTON

        MOVE    *A13(MEN_CUR),A0,W        ;GET "CURRENT" ENTRY.
        CALLR   GET_MENU_DATA             ;A1=CURRENT_OFFSET  A2=TEXT  A3=ROUTINE
        MOVE    A0,*A13(MEN_OFF),W        ;STORE THE OFFSET (CHOICE NUM)
        MOVE    A3,*A13(MEN_ROUT),L       ;AND THE ROUTINE POINTER
        MOVI    MDUN_PID,A0
        MOVE    A0,*A13(PROCID),W         ;CHANGE OUR ID.

MENU_DONE:
        SLEEP   20
        JRUC    MENU_DONE                 ;NOW HANG TILL DISPATCHER SEES ID.

**************************************************************************
*                                                                        *
*                 MENU UTILITIES                                         *
*                                                                        *
**************************************************************************
**************************************************************************
*                                                                        *
*          BUTTON_STALL                                                  *
*                                                                        *
*          THIS IS CALLED WHEN THE MENU GETS A BUTTON HIT.               *
*          A1 HAS THE BIT OF THE BUTTON.                                 *
*                                                                        *
*          WE PAINT THE MENU SQUARE TO FEEDBACK THE HIT.                 *
*                                                                        *
*          THEN WE HANG ON THE BUTTON UNTIL ITS LET GO.                  *
*                                                                        *
**************************************************************************
BUTTON_STALL:
	MOVE    A2,@LAST_BUT,L       ;PUSH THE BUTTON STATE

        MOVE    @SCODE,A0,W          ;NO CASH FOR REPEAT SOUND CODES
        MOVE    @DCODE,A1,W
        OR      A0,A1
        JRNZ    DONT_WAIT            ;ITS A SOUND REPEAT....DON'T HOLD EITHER!

;        SOUND1  DOOROSND             ;MAKE SELECT SOUND

        MOVE    *A13(MEN_CUR),A0,W   ;GET CURRENT SELECTION
        MOVI    ROBO_ORANGE,A1
        CALLR   MENU_BAR             ;CHANGE THE BAR COLOR.

        CALLR   GET_MENU_DATA             ;GET OUR TEXT POINTER BACK
        MOVI    ROBO_WHITE,A1            ;WHITE ON ORANGE DURING HOT MOMENT
        JSRP    MENU_TEXT                 ;AND WRITE INVERTED TEXT

        MOVE    @LAST_BUT,A8,L            ;GET BUTTON BACK
        MOVI    08H,A9                    ;MINIMUM TIME FOR BUTTON HIGHLITE

        MOVI    2AH,A10              ;.5 SECONDS OF ADVANCE HOLD-DOWN
*                                     ;WILL EXIT TEST MODE.
WAIT_FOR_RELEASE:
        CMPI    ADV_HIGH,A8               ;IS IT ADVANCE BUTTON?
        JRNZ    NOT_ADV                   ;NOPE.....NEVER MIND

        DEC     A10                  ;1 LESS TIME UNIT
        JRZ     DIAG_EX            ;IF HE HOLDS ADVANCE...WE'RE GONE!

NOT_ADV:  
	SLEEP   1
         
        MOVE    A9,A9                ;REDUCE FOR HELD TIME
        JRZ     WAIT_1               ;ZEROED OUT ALREADY.
        DEC     A9

WAIT_1:
        CALLR   FORM_SWS        ;WAIT FOR THIS ONE TO GO TO ZERO
        AND     A8,A0                ;IS OUR BUTTON STILL DOWN?
        JRNZ    WAIT_FOR_RELEASE
*
*       ITS RELEASED...NOW SHOW ORANGE BAR FOR MINIMUM TIME

        INC     A9                   ;MAKE SURE A9 HAS 1 OR MORE
WAIT_2:
        SLEEP   1
        DSJS    A9,WAIT_2

DONT_WAIT:
        MOVE    *A13(MEN_CUR),A0,W   ;GET CURRENT SELECTION
        CLR     A1                   ;ERASE BAR
        CALLR   MENU_BAR             ;CHANGE THE BAR COLOR.

        CALLR   GET_MENU_DATA             ;GET OUR TEXT POINTER BACK
        MOVE    *A13(MEN_COLR),A1,W       ;RE-PLOT THE NORMAL TEXT
        JSRP    MENU_TEXT                 

        SLEEP   2                    ;NOW GIVE SOME BOUNCE PROTECTION.

        RETP

         .STRING         " CARNAGE - COPYRIGHT 1990 WILLIAMS ELECTRONICS GAMES INC. "
         .STRING         " ALL RIGHTS RESERVED "
         .STRING         " -EPJ -GNP -TRA -LED -RCA -MT -JEH -JRN -ML -GWS -LIN -AL -BLS"
         .STRING         " -ML -TJE -DTW -RMG -WBD -JB -JRH -DP -JP "
         .EVEN

**************************************************************************
*                                                                        *
*          STUFF_MENU_PROCESS                                            *
*                                                                        *
*          THIS IS CALLED TO STUFF THE MENU ROM DATA INTO THE            *
*          CURRENT PROCESSES PDATA AREA.                                 *
*                                                                        *
**************************************************************************
STUFF_MENU_PROCESS:
	MMTM    SP,A0,A1,A2,A3,A8
        MOVE    A13,A0               ;POINT IN PROCESS AREA
        ADDI    MEN_ROM,A0           ;THIS IS WHERE 1ST TIDBIT GOES
        MOVE    A8,*A0+,L            ;STORE OUR BASE POINTER IN STRUCTURE
        ADDI    MR_WORDS,A8          ;MOVE TO WORD LIST

        MOVI    WORD_ENTS,A2         ;NOW THIS MANY MORE WORDS.

GMS1:     
	MOVE    *A8+,A1,W
        MOVE    A1,*A0+,W
        DSJS    A2,GMS1
*
*       ALL THE MENU PARAMETERS ARE NOW IN THE PDATA AREA.
*       A8 POINTS AT THE FIRST ITEM TO DISPLAY.
*
        MOVE    A8,*A13(MEN_TPTR),L  ;STORE IN PROCESS AREA.
*
*       NOW WE WANT TO FIND THE NUMBER OF ENTRIES IN THE MENU
*
        CLR     A0                        ;START AT #1.
HOW_MANY:
        INC     A0                        ;MOVE TO NEXT ENTRY.
        CALLR   GET_MENU_DATA             ;GET THE PARAMETERS FOR THIS ENTRY
        MOVE    A2,A2                     ;AND SEE IF A2=0
        JRNZ    HOW_MANY                  ;ITS REAL.....PUT IT UP.

        DEC     A0                        ;PREVIOUS LINE WAS THE LAST.
        MOVE    A0,*A13(MEN_ENTS),W       ;STUFF NUMBER IN MENU.

        MOVE    A9,A9                     ;DID BOZO PASS ZERO AS CURRENT?
        JRZ     USE_LAST
        CMP     A0,A9                     ;MAKE SURE ITS NOT TOO HIGH
        JRHI    USE_LAST                  ;A9 IS TOO HIGH
        MOVE    A9,A0                     ;USE THE ONE PAST

USE_LAST: 
	MOVE    A0,*A13(MEN_CUR),W   ;MAKE ENTRY "1" CURRENT.
	MMFM    SP,A0,A1,A2,A3,A8
	RETS

**************************************************************************
*                                                                        *
*          DO_MENU_LINE                                                  *
*                                                                        *
*          A0 HAS THE LINE TO DO. (1 THROUGH N).                         *
*          PRINT TEXT NORMAL IF NOT "MEN_CUR".                           *
*          PRINT INVERT BAR FOLLOWED BY BLACK TEXT IF                    *
*          ITS THE CURRENT ENTRY.                                        *
*                                                                        *
**************************************************************************
DO_MENU_LINE:
        CALLR   GET_MENU_DATA             ;GET "CURRENT" IN A1
        CMP     A0,A1                     ;IS IT "CURRENT" ENTRY?
        JRZ     DO_CURRENT_ENT            ;YEP....DO INVERSE STUFF
*
*       A0 HAS OFFSET (FOR POSITIONING)
*       A2 HAS TEXT POINTER (FOR MESSAGE)
*       A1 NEEDS COLOR FOR MESSAGE.
*
        MOVE    *A13(MEN_COLR),A1,W       ;USE THE NORMAL ENTRY COLOR
        JSRP    MENU_TEXT                 ;PUT UP THE "TEXT" PORTION.
        RETP                              ;AND RETURN

DO_CURRENT_ENT:       
        MOVI    ROBO_WHITE,A1            ;DO THE BAR IN WHITE (AT A0 HEIGHT)
        CALLR   MENU_BAR                  ;PUT IT UP (A0 PRESERVED)

        CALLR   GET_MENU_DATA             ;GET OUR TEXT POINTER BACK
        MOVE    *A13(MEN_SCOL),A1,W       ;GET "SELECTED" COLOR
        JSRP    MENU_TEXT                 ;AND WRITE INVERTED TEXT
        RETP                              ;THAT'S ALL FOLKS.

**************************************************************************
*                                                                        *
*          UN_SELECT                                                     *
*                                                                        *
*          THIS IS CALLED TO "UN-SELECT" THE CURRENT ENTRY.              *
*                                                                        *
**************************************************************************
UN_SELECT:
        MOVE    *A13(MEN_CUR),A0,W        ;POINT AT CURRENT ENTRY
        CLR     A1                        ;USE BLACK FOR BACKGROUND
        CALLR   MENU_BAR                  ;THIS REMOVES THE BAR.

        CALLR   GET_MENU_DATA             ;NOW GET A2 TO TEXT POINTER
        MOVE    *A13(MEN_COLR),A1,W       ;USE THE NORMAL ENTRY COLOR
        JSRP    MENU_TEXT                 ;PUT UP THE "TEXT" PORTION.
        RETP                              ;AND RETURN

**************************************************************************
*                                                                        *
*          MENU_BAR                                                      *
*                                                                        *
*          THIS IS CALLED TO PUT UP THE SELECTION BAR FOR                *
*          THE ENTRY IN A0, IN THE COLOR IN A1.                          *
*                                                                        *
*          THIS ROUTINE MUST PRESERVE A0.                                *
*                                                                        *
**************************************************************************
* STRNGLEN - RETURNS THE LENGTH, IN PIXELS, OF A GIVEN STRING		 *
* A8 = PTR TO STRING							 *
* A10 = [Y,X] SPACING OF STRING						 *
* A11 = PTR TO FONT TABLE						 *
* RETURNS:								 *
* A7 = LENGTH OF STRING							 *
* Z BIT SET IF LENGTH IS ZERO						 *
*
*        FOR FILLAREA
*
* A1 = <COLOR><PALETTE>
* A3 = DAG OF AREA [YPOS,XPOS]						 
* A4 = [Y,X] SIZE OF AREA						 
*
MENU_BAR: 
	MMTM    SP,A0,A1,A3,A4,A5,A6,A7,A8    ;SAVE THE OFFSET
        MMTM    SP,A1                     ;SAVE COLOR!
        CALLR   GET_MENU_DATA             ;GET THE TEXT POINTER
        CALLR   STLEN_SETUP               ;SETUP FOR STRLEN CALL.
        CALLA   STRNGLEN                  ;FIND WIDTH OF STRING.
*
*       A7 HAS LENGTH OF STRING.
*
*       WE NEED TO GET INTO A3 THE COORDINATES UF UPPER LEFT
*       AND A4 THE LENGTH.
*
*       IF WE'RE CENTERING, WE USE THE BAR WIDTH PARAMETER
*       ALONG THE CENTER LINE.
*
*       IF WE'RE LEFT JUSTIFIED, WE'LL LET THE BOX GO THE
*       LENGTH OF THE TEXT FOR NOW.
*
        MOVE    *A13(MEN_ULX),A3,W        ;LEFT X IN A3                    
*
*       IF WE'RE CENTERING....WE NEED TO MOVE THE "LEFT X" BACK HALF
*       THE WIDTH OF THE STRING.
*
        MOVE    *A13(MEN_ROM),A6,L        ;GET ROM POINTER
        MOVE    *A6(MR_TCAL),A6,L         ;CHECK ROUTINE
        CMPI    STRCNRM,A6
        JRNZ    NOT_CENTERING
*
*       WE'RE CENTERING....CENTER X IS IN A3
*
        MOVE    *A13(MEN_BWID),A7,W       ;A7 IS THE REGISTER FOR BAR WIDTH
        MOVE    A7,A4                     ;GET COPY IN A4
        SRL     1,A4                      ;1/2 OF WIDTH COMES OFF OF CENTER
        SUB     A4,A3                     ;A3 NOW HAS "LEFT X" 
        JRUC    CENTERING                 ;A7 IS WIDTH...A3 IS X

*
*       LEFT JUSTIFIED....DO IT THE OLD WAY!
*
NOT_CENTERING:
        MOVE    *A13(MEN_BDX),A4,W        ;GET EXTRA X UNITS FOR BAR
        SUB     A4,A3

*       NOW ADD TWICE THE EXTRA X TO THE STRING LENGTH TO
*       FORM THE BAR LENGTH.
*
        SLL     1,A4                      ;NOW DOUBLE THE EXCESS DX FOR BAR
        ADD     A4,A7                     ;NOW A7 HAS WIDTH OF BAR

CENTERING:
        SUBI    C_KLUDGE,A3          ;KLUDGE TO NULLIFY FINAL SPACE.

        CALLR   GET_ENTRY_Y               ;GET Y FOR ENTRY IN A5

        MOVE    *A13(MEN_BDY),A6,W        ;GET BAR DY (NEGATIVE)
        ADD     A6,A5                     ;ADJUST Y BY BAR DY
        SLL     16,A5                     ;SHIFT Y INTO POSITION

        ADD     A5,A3                     ;A3 NOW POINTS AT UPPER LEFT

        MOVE    *A13(MEN_BAR),A4,W        ;Y HEIGHT OF BAR
        SLL     16,A4                     ;IN POSITION
        ADD     A7,A4                     ;A7 HAS X WIDTH OF BAR.

        MMFM    SP,A1                     ;NOW GET COLOR BACK!
        SLL     16,A1                     ;SHIFT COLOR TO HIGH HALF (PAL. 0) 
        CALLA   FILLAREA                  ;FILL IT UP!

	MMFM    SP,A0,A1,A3,A4,A5,A6,A7,A8    ;SAVE THE OFFSET
	RETS

**************************************************************************
*                                                                        *
*          MENU_TEXT                                                     *
*                                                                        *
*          THIS IS CALLED TO DISPLAY THE TEXT FOR AN ENTRY.              *
*                                                                        *
*          A0 HAS OFFSET (FOR POSITIONING)                               *
*          A1 HAS COLOR FOR MESSAGE.                                     *
*          A2 HAS TEXT POINTER (FOR MESSAGE)                             *
*                                                                        *
*          WE NEED TO SHIFT THE DATA FOR THE TEXT ROUTINE                *
*          AS FOLLOWS:                                                   *
*                                                                        *
*          A0 = SLEEP                                                    *
*          A6 = COLOR                                                    *
*          A8 = POINTER                                                  *
*          A9 = ADDRESS                                                  *
*          A10 = SPACING                                                 *
*          A11 = FONT                                                    *
*                                                                        *
**************************************************************************
MENU_TEXT:
        CALLR   GET_ENTRY_Y               ;GET Y FOR ENTRY IN A5
        SLL     16,A5                     ;SHIFT Y INTO POSITION
        MOVE    *A13(MEN_ULX),A9,W        ;GET THE X
        ADD     A5,A9                     ;A9 SET WITH SCREEN ADDRESS

        MOVE    A1,A6                     ;COLOR
        CLR     A0                        ;NO SLEEP

        CALLR   STLEN_SETUP

        MOVE    *A13(MEN_ROM),A1,L
        MOVE    *A1(MR_TCAL),A1,L         ;GET THE ROUTINE TO USE
        JUMP    A1                        ;AND CALL IT!

STLEN_SETUP:
        MOVE    A2,A8                     ;TEXT POINTER
        MOVI    SPACING20,A10             ;SPACING
        MOVE    *A13(MEN_ROM),A11,L
        MOVE    *A11(MR_FONT),A11,L       ;LOAD FONT
        RETS

**************************************************************************
*                                                                        *
*          MENU JOYSTICK HANDLING                                        *
*                                                                        *
**************************************************************************
ST_STICK:
        CALLR   FORM_SWS           ;THIS LATCHES ANYONE ALREADY DOWN.
        CLR     A0
        MOVE    A0,*A13(MEN_ACT),L      ;SHOW THAT WE'RE "ACTING" ON NONE.
        MOVE    A0,*A13(MEN_TYPO),W     ;CLEAR TYPOMATIC COUNTER.
        MOVE    A0,*A13(MEN_HITS),W     ;CLEAR OUT "CONSECUTIVE HITS"
        RETP
*
*       GETSTICK......RETURN DEBOUNCED/TYPOMATIC FOR
*                       UP AND DOWN......OR EDGE OUT
*                       ANY BUTTON....(INCLUDING ADVANCE)
*
*       RETURN A0=
*
*       NOTHING = 0
*       UP = 1
*       DOWN = 2
*       BUTTON = 3
*
*       A2 = BUTTON BIT ON BUTTON HITS
*
TYPO_COUNT       EQU     4
TYPO_STALL       EQU     25
UP_BITS          EQU     101H
DOWN_BITS        EQU     202H
UP_OR_DOWN       EQU     UP_BITS+DOWN_BITS
SW_BUTS          EQU     0F0F0H
CN_BUTS          EQU     3500000H                    ;BOTH STARTS, ADV, COIN BUT.
BUTTONS          EQU     SW_BUTS+CN_BUTS
MENU_TYPO        EQU     (TYPO_COUNT*10000H)+14      ;14 HITS FOR MENU TILL STUCK
*
*        TO USE THIS.......FIRST JSRP ST_START.
*                          THIS STICKS CLOSED SWITCHES AND
*                          INITIALIZES COUNTERS.
*
*                          DATA IS STORED IN YOUR PDATA
*                          AREA.....AT AREAS DETERMINED
*                          BY THE "MEN_" STRUCTURE.  THESE
*                          LOCATIONS MUST BE AVAILABLE.
*
*                          A8-A11 ARE NOT TOUCHED.
*
*         AFTER ST_START.....READ AS FOLLOWS.
*
*
*         LOOP      SLEEP  1
*                   MOVI   TYPO_PARMS,A5
*                   JSRP   GETSTICK
*
*                   <LOGICAL STICK STATE RETURNED IN A0>
*                   <ACT ON LOGICAL STATE>
*
*                   JRUC LOOP
*                   
*
*        INPUT A5-----TOP HALF IS TYPOMATIC RATE
*                     LOW HALF IS COUNT TILL STICK IS CALLED STUCK
*
GETSTICK:
	MOVE    A5,A6
        SRL     16,A5                ;TYPO RATE IN A5
        ANDI    WORD_MASK,A6         ;STUCK HIT COUNT IN A6

        CALLR   FORM_SWS        ;SEE WHAT THEY LOOK LIKE NOW.
*
*       RETURN CURRENT STATE IN A0..PREVIOUS STATE IN A1.
*
        NOT     A1                   ;LAST = 0 AND NOW = 1 MEANS EDGE!

        AND     A1,A0                ;1'S WHERE WE HAVE POSITIVE EDGE.
        MOVE    A0,A4                ;KEEP NEW EDGE STATE IN A4!

        ANDI    BUTTONS,A0           ;BUTTON SAYS ACT....IGNORE STICK!
        JRNZ    TEST_BUTS            ;NEW BUTTON......RETURN IT!
*
*       NO BUTTON.....DO STICK TYPOMATIC STUFF!
*
        MOVE    *A13(MEN_ACT),A2,L   ;IS THERE ONE TO WATCH?
        JRZ     NEW_SCAN             ;NOPE....LOOK FOR NEW STUFF!
*
*       WE HAVE ONE THAT'S DOWN THAT WE WANT TO WATCH.
*
        CALLR   FORM_SWS        ;SEE WHAT THEY LOOK LIKE NOW.
        AND     A2,A0                ;IS IT STILL MADE?
        JRZ     GS_STICK_OPEN        ;NOPE.......CLEAR OUT ITS STATE.
*
*       ITS STILL MADE........DO TYPOMATIC.
*
        MOVE    *A13(MEN_TYPO),A1,W  ;DECREMENT TYPOMATIC COUNTER
        DEC     A1
        MOVE    A1,*A13(MEN_TYPO),W  ;AND PUT BACK IN MEMORY
        JRNZ    GS_ZERO              ;NOT TIME YET.....RETURN NOTHING
*
*       WE HAVE A TYPOMATIC HIT.....WE NEED TO TURN SWITCH BIT (A0)
*       INTO "UP" OR "DOWN" AND RE-LOAD TYPOMATIC COUNTER.
*
*
        MOVE    *A13(MEN_HITS),A1,W  ;GET NUMBER OF HITS
        INC     A1                   ;AFTER 15 TYPOS.....KILL TILL OPEN!
        MOVE    A1,*A13(MEN_HITS)    ;
        CMP     A6,A1                ;TOO MANY HITS?
        JRHS    GS_GONE              ;YEP....CALL THIS "STUCK"
        MOVE    A5,*A13(MEN_TYPO),W  ;TYPOMATIC COUNTER RELOADED.

RETURN_UP_DOWN:
        MOVE    A0,A1                ;GET THE BIT
        MOVE    A1,A2                ;MAKE A COPY
        MOVK    1,A0                 ;ASSUME UP
        ANDI    UP_BITS,A1           ;IS IT AN "UP" BIT
        JRNZ    GS_X                 ;YEP...RETURN UP.
        MOVK    2,A0                 ;ASSUME DOWN
        ANDI    DOWN_BITS,A2         ;IS IT A "DOWN" BIT
        JRNZ    GS_X                 ;YEP...RETURN "DOWN"
*
*        NOT A TYPOMATIC CONDITION.
*

GS_GONE:  
	CLR     A0                   ;CLEAR OUT CURRENT HIT.
        MOVE    A0,*A13(MEN_ACT),L   ;INDICATE READY FOR NEXT HIT!
        JRUC    GS_X                 ;AND RETURN THIS ZERO (NOTHING!)
*
*       STICK THAT WAS CLOSED OPENED......STOP BOUNCE UPWARD!
*
GS_STICK_OPEN:
        SLEEP   6
        JRUC    GS_GONE              ;NOW.....CLEAR OUT FOR NEXT HIT.
*
*       CONTROL COMES HERE WHEN NO BUTTONS ARE PENDING.
*
NEW_SCAN:
        MOVE    A4,A0                ;LOOK AT THE NEW EDGES.

        ANDI    UP_OR_DOWN,A0        ;IS IT UP OR DOWN?
        JRZ     GS_ZERO              ;NO STICK....RETURN NO ACTION!

        CALLR   FRST_BIT             ;REDUCE TO ONE BIT.
        MOVE    A0,*A13(MEN_ACT),L   ;STORE THIS BIT

        MOVI    TYPO_STALL,A1
        MOVE    A1,*A13(MEN_TYPO),W  ;TYPOMATIC COUNTER SET FOR LONG STALL.

        CLR     A1
        MOVE    A1,*A13(MEN_HITS),W  ;LOAD UP A BUNCH OF HITS 
        JRUC    RETURN_UP_DOWN       ;RETURN CORRECT CODE UP OR DOWN
*
*       NOT UP OR DOWN......SEE IF ITS A BUTTON.
*
TEST_BUTS:
*
*       ITS A BUTTON...ALL NEW BUTTON EDGES IN A0
*
        CALLR   FRST_BIT             ;USE 1 OF THEM.

        MOVE    A0,A2                ;RETURN THE BIT.

        MOVI    3,A0                 ;RETURN THAT ITS A BUTTON.
        JRUC    GS_X                 ;STUCK PROCESSING WILL BE AUTOMATIC.

GS_ZERO:  
	CLR     A0                   ;RETURN NO SWITCH.
GS_X:     
	RETP

**************************************************************************
*                                                                        *
*          FRST_BIT                                                      *
*                                                                        *
*          A0 HAS 1 OR MORE BITS SET....RETURN 1 OF THEM.                *
*                                                                        *
**************************************************************************
FRST_BIT: 
	MMTM    SP,A1,A2
        MOVK    1,A1            ;SHIFT TILL WE FIND IT.
FB1:      
	MOVE    A0,A2
        AND     A1,A2
        JRNZ    GOT_IT          ;WE HAVE ON (IN A1)
        SLL     1,A1            ;SHIFT IT
        JRUC    FB1
GOT_IT:   
	MOVE    A1,A0           ;RETURN THE BIT
	MMFM    SP,A1,A2
	RETS

**************************************************************************
*                                                                        *
*          FORM_SWS                                                 *
*                                                                        *
*          GET THE SWITCHES....1=CLOSED.....AND SAVE                     *
*          THIS SCAN AS "LAST STATE".  RETURN:                           *
*                                                                        *
*          CURRENT STATE IN A0                                           *
*          PREVIOUS STATE IN A1                                          *
*                                                                        *
**************************************************************************
FORM_SWS:
        MOVE    *A13(MEN_STIK),A1,L  ;RETURN PREVIOUS STATE
        MOVE    @SWITCH,A0,L         ;GET BOTH SWITCH WORDS
        NOT     A0                   ;COMPLEMENT
        MOVE    A0,*A13(MEN_STIK),L     ;SAVE "STUCK" STATE.
        RETS

**************************************************************************
*                                                                        *
*          GET_MENU_DATA                                                 *
*                                                                        *
*          A0 IS OFFSET OF ENTRY OF INTEREST                             *
*                                                                        *
*          RETURN  A1 = CURRENT OFFSET                                   *
*                  A2 = TEXT POINTER                                     *
*                  A3 = ROUTINE                                          *
*                                                                        *
**************************************************************************
GET_MENU_DATA:
	MMTM    SP,A0                ;DON'T ALTER A0

        CALLR   PM_ENTRY     ;POINT A1 AT ENTRY

        MOVE    *A1(MENU_TEXT_PTR),A2,L   ;FETCH THE TEXT POINTER
        MOVE    *A1(MENU_ROUTINE),A3,L    ;FETCH THE ROUTINE
        MOVE    *A13(MEN_CUR),A1,W        ;RETURN CURRENT ENTRY IN A1
	MMFM    SP,A0                ;DON'T ALTER A0
	RETS

**************************************************************************
*                                                                        *
*          PM_ENTRY                                                      *
*                                                                        *
*          A0 = MENU ENTRY OF INTEREST                                   *
*          RETURN A1 -> POINTS AT <TEXT><ROUTINE><HELP> FOR THIS         *
*          ENTRY.                                                        *
*                                                                        *
**************************************************************************
PM_ENTRY:
        MMTM    SP,A0
        DEC     A0                   ;INDEX FROM ZERO
        MOVI    MENU_ENTRY_SIZE,A1   ;TIMES SIZE PER ENTRY 
        MPYU    A0,A1                ;A1 CONTAINS OFFSET INTO TABLE

        MOVE    *A13(MEN_TPTR),A0,L  ;GET THE BASE OF THE MENU TEXT ENTRIES
        ADD     A0,A1                ;ADD TO OFFSET
	MMFM    SP,A0
	RETS

**************************************************************************
*                                                                        *
*          PLOT_HELP                                                     *
*                                                                        *
*          THIS ROUTINE PLOTS (OR CLEARS) THE HELP AREA                  *
*          FOR THE CURRENT ENTRY.                                        *
*                                                                        *
**************************************************************************
PLOT_HELP:
        MOVE    *A13(MEN_CUR),A0,W        ;GET CURRENT ENTRY
        CALLR   PM_ENTRY          ;A1 POINTS AT GROUP
        MOVE    *A1(MENU_HELP),A8,L       ;GET HELP TABLE
        CMPI    NO_HELP,A8                ;NOT A "HELP" SITUATION?
        JRZ     NO_HELP_FOR_THIS_ONE
        CMPI    ADJ_HELP,A8               ;ADJUSTMENT HELP REQUESTED?
        JAEQ    DO_ADJH                   ;THEN DO IT IN ADJ MODULE!
        CMPI    SND_HELP,A8               ;ARE WE IN SOUND TEST?
        JREQ    DO_SHELP
        CMPI    SND_PLAY,A8
        JREQ    DO_SPLAY
        CALLR   DO_HELP_MENU
NO_HELP_FOR_THIS_ONE:
         RETS

**************************************************************************
*                                                                        *
*          DO_SHELP                                                      *
*                                                                        *
*          THIS IS CALLED FOR EACH NON PLAYING ENTRY IN THE SOUND        *
*          TABLE MENU.  IT CAUSES THE SOUND BOARD TO BE SHUT             *
*          UP AND THE BOTTOM LINE (WHERE TITLES APPEAR)                  *
*          TO BE ERASED.                                                 *
*                                                                        *
**************************************************************************
DO_SHELP:	
	MOVE    @SND_MADE,A0,W  ;DID SOMEONE MAKE A SOUND?
        JRZ     DO_SH1          ;NOPE
        CLR     A0
        MOVE    A0,@SND_MADE,W  ;CLEAR THIS AND RESET THE BOARD!
        MOVE    A0,@SCODE,W
        MOVE    A0,@DCODE,W
        CALLA   QSNDRST	        ;kill any sounds in progress
DO_SH1:   
	CALLR   BLNKSNAM        ;BLANK OUT ANY WRITING!
        RETS
*
*       A0 CONTAINS 3 FOR SYNTHESIZER...4 FOR DIGITIZER...
*       IF CORRESPONDING "CODE" BYTE IS NON ZERO, THEN DISPLAY
*       THE TEXTLINE THAT CORRESPONDS.  ELSE BLANK OUT THE
*       AREA.
*
DO_SPLAY: 
	CALLR   BLNKSNAM        ;BLANK OUT LAST MESSAGE
        CMPI    3,A0            ;SYNTHESIZER?
        JRZ     CK_SYNT         ;YEP.
*
*       DIGITIZER.
*
        MOVE    @SCODE,A1,W     ;HOLD INFO IF SYNTH WAS RUNNING
        CLR     A0
        MOVE    A0,@SCODE,W     ;CLEAR OUT SYNTH CODE
        MOVE    @DCODE,A0       ;ANY CODE
        JRZ     DO_SPQX         ;NOTHING HERE.....SHUT UP SOUND SYS.

        MOVI    DTABLE,A1       ;BASE OF POINTER TABLE FOR DIGITIZER
        JRUC    DO_SP1          ;PRINT THE STRING.


CK_SYNT:  
	MOVE    @DCODE,A1,W     ;HOLD INFO IF DIGITIZER WAS RUNNING
        CLR     A0
        MOVE    A0,@DCODE,W     ;CLEAR OUT DIG CODE
        MOVE    @SCODE,A0       ;ANY CODE
        JRZ     DO_SPQX          ;NOTHING HERE.

        MOVI    STABLE,A1       ;BASE OF POINTER TABLE FOR DIGITIZER

DO_SP1:   
	CALLR   MEN_NUMS                           ;A4 = LEFT X  A5 = RIGHT X
        ADDI    10000H*SND_MESS_Y,A4               ;UPPER LEFT Y
        ADDI    10000H*(SND_MESS_Y+SND_BOX_H),A5   ;UPPER LEFT X
        MOVI    ROBO_WHITE,A9
        CALLR   STD_BORD       

        DEC     A0                        ;INDEX FROM 1.
        SLL     5,A0
        ADD     A0,A1
        MOVE    *A1,A2,L                  ;NOW WE HAVE THE MESSAGE

        MOVI    SND_INST,A8
        JSRP    L_MESS                    ;PUT INSTRUCTION OUT.

        MOVI    SND_SETUP,A8
        CALLA   LM_SETUP

        MOVE    A2,A8                   
        JSRP    LM_FINIS                  ;DO THE DEED
        RETS                              ;AND RETURN

DO_SPQX:  
	MOVE    A1,A1                     ;OUR SELECTION ISN'T RUNNING...WAS OTHER?
        JRZ     DO_SPX                    ;NOPE
        CALLA   QSNDRST                   ;KILL SOUNDS IN PROGRESS
        CLR     A0
        MOVE    A0,@SND_MADE,W            ;NO RESET NECESSARY NOW
DO_SPX:   
	RETS

**************************************************************************
*                                                                        *
*          BLNKSNAM                                                      *
*                                                                        *
*          CALLED TO BLANK OUT THE SOUND CODE NAME DURING                *
*          SOUND TEST.                                                   *
*                                                                        *
**************************************************************************
*
*        A3 = POINTER
*        A4 = SIZE
*
BLNKSNAM:
        MOVI    (SND_MESS_Y*10000H)+20H,A3
        MOVI    (SND_BOX_H*10000H)+1E0H,A4
        JAUC    BLNKAREA                  ;ITS BLANK!

**************************************************************************
*                                                                        *
*          GET_ENTRY_Y                                                   *
*                                                                        *
*          THIS RETURNS THE Y POSITIONS FOR THE ENTRY SPECIFIED          *
*          IN A0.                                                        *
*                                                                        *
*          A5 = Y VALUE IN UNITS.                                        *
*                                                                        *
**************************************************************************
GET_ENTRY_Y:
        MMTM    SP,A0,A1
        MOVE    *A13(MEN_ULY),A5,W
        MOVE    *A13(MEN_DY),A1,W
        DEC     A0
        MPYU    A0,A1                ;A1 HAS OFFSET PER ENTRY
        ADD     A1,A5
	MMFM    SP,A0,A1
	RETS

**************************************************************************
*                                                                        *
*          MENU_BORDER                                                   *
*                                                                        *
*          THIS IS CALLED TO PUT A BORDER AROUND THE MENU.               *
*                                                                        *
*          A8 = MENU STRUCTURE                                           *
*          A9 = 1st item to activate as current                          *
*                                                                        *
*          BORDER IS DONE IN MENU TEXT COLOR                             *
*                                                                        *
*          THIS ASSUMES MENU IS IN THE CENTERING FORMAT                  *
*                                                                        *
**************************************************************************
*
*        1ST WE NEED TO FIND UPPER LEFT.
*
*
*        X = MENU_X - (BAR_WIDTH/2) - 2       (LESS BORDER WIDTH)
*        Y = MENU_Y - BDY                     (LESS BORDER HEIGHT)
*
*        LOWER RIGHT :
*
*        X = MENU_X + (BAR_WIDTH/2) - 2       (PLUS BORDER WIDTH)
*        Y = MENU_Y + (MENU_ENTRIES-1) * DY)) - BDY + BAR_HITE
*
*
MENU_BORDER:
        MMTM    SP,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9
        CALLR   STUFF_MENU_PROCESS   ;MOVE DATA INTO PDATA AREA
*
*       FIRST COMPUTE UPPER LEFT
*
        CALLR   MENU_UL_A4_A5             ;GET UPPER LEFT COORDINATES
        SLL     16,A5
        ADD     A5,A4                     ;A4 POINTS TO UPPER LEFT.
*
*       FORM LOWER RIGHT
*
        CALLR   MENU_LR_A6_A5
        SLL     16,A5                     ;SHIFT A5 DOWN
        ADD     A6,A5                     ;A5 POINTS AT LOWER RIGHT

        MOVE    *A13(MEN_COLR),A9,W       ;GET MENU TEXT COLOR
        CALLR   STD_BORD

	MMFM    SP,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9
	RETS

**************************************************************************
*                                                                        *
*          MCSETUP                                                       *
*                                                                        *
*          RETURN:                                                       *
*                  A0 = CENTER OF MENU                                   *
*                  A1 = 1/2 BAR WIDTH                                    *
*                  A2 = Y FOR FIRST LINE OF TEXT OF MENU                 *
*                  A3 = DELTA Y (NEGATIVE TO GET FROM TEXT TO BAR.       *
*                                                                        *
**************************************************************************
MCSETUP:
        MOVE    *A13(MEN_ULX),A0,W        ;UPPER LEFT X (ACTUALLY CENTER)
        MOVE    *A13(MEN_BWID),A1,W       ;BAR_WIDTH
        SRL     1,A1                      ;ALL CALCS USE BAR_WIDTH/2
        MOVE    *A13(MEN_ULY),A2,W        ;UPPER LEFT Y
        MOVE    *A13(MEN_BDY),A3,W        ;DELTA Y (NEGATIVE)
        RETS


**************************************************************************
*                                                                        *
*          MENU_UL_A4_A5                                                 *
*                                                                        *
*          RETURN WINDOW UPPER LEFT CORNER                               *
*                                                                        *
*          A4 = X                                                        *
*          A5 = Y                                                        *
*                                                                        *
**************************************************************************
MENU_UL_A4_A5:
        MMTM    SP,A0,A1,A2,A3
        CALLR   MCSETUP                   ;STUFF THE REGGIES
        MOVE    A0,A4                     ;FORM ULX
        SUB     A1,A4
        SUBI    C_KLUDGE,A4          ;A4 HAS UPPER LEFT X

        MOVE    A2,A5
        ADD     A3,A5                     ;A5 HAS UPPER LEFT Y

        SUBI    MB_XWID+GAP,A4            ;NOW WE POINT AT UPPER LEFT FOR FRAME
        SUBI    MB_YWID+GAP,A5
	MMFM    SP,A0,A1,A2,A3
	RETS

**************************************************************************
*                                                                        *
*          MENU_LR_A6_A5                                                 *
*                                                                        *
*          RETURN WINDOW LOWER RIGHT CORNER                              *
*                                                                        *
*          A6 = X                                                        *
*          A5 = Y                                                        *
*                                                                        *
**************************************************************************
MENU_LR_A6_A5:
        MMTM    SP,A0,A1,A2,A3
        CALLR   MCSETUP                   ;STUFF THE REGGIES

        MOVE    A0,A6                     ;LOWER RIGHT X
        ADD     A1,A6
        SUBI    C_KLUDGE,A6          ;THIS IS THE X

        MOVE    *A13(MEN_ENTS),A0,W       ;THIS IS LAST ENTRY
        CALLR   GET_ENTRY_Y               ;A5 HAS THE Y FOR THE LAST ENTRY
        ADD     A3,A5                     ;A5 NOW HAS TOP OF LAST BOX
        MOVE    *A13(MEN_BAR),A7,W        ;HEIGHT OF BAR
        ADD     A7,A5                     ;A5 NOW HAS LOWER RIGHT Y

        ADDI    MB_YWID+GAP,A5
        ADDI    MB_XWID+GAP,A6            ;THIS IS END OF BORDER
	MMFM    SP,A0,A1,A2,A3
	RETS


**************************************************************************
*                                                                        *
*          F_TITLE                                                       *
*                                                                        *
*          THIS IS CALLED TO FRAME A TITLE IN THE SAME WIDTH             *
*          AS THE MAIN TITLE.                                            *
*                                                                        *
*          A0 = Y LEVEL OF 15 POINT TEXT                                 *
*          A9 = COLOR                                                    *
*                                                                        *
**************************************************************************
F_TITLE:  
	MMTM    SP,A4,A5,A0
        MOVE    A0,A4           ;COPY Y
        SUBI    12,A4
        SLL     16,A4
        ADDI    TIT_ULX,A4      ;UPPER LEFT SET

        MOVE    A0,A5           ;LOWER RIGHT
        ADDI    27,A5
        SLL     16,A5
        ADDI    TIT_LRX,A5      ;LOWER RIGHT SET

        CALLR   STD_BORD       
	MMFM    SP,A4,A5,A0
	RETS

FIRST_BORDER_COLOR       EQU     0E0E0H
LAST_BORDER_COLOR        EQU     0EFEFH
**************************************************************************
*                                                                        *
*          G_BORDER                                                      *
*                                                                        *
*          THIS IS CALLED TO DO A "HSTD TABLE" TYPE CYCLING              *
*          BORDER.  THIS ROUTINE GETS:                                   *
*                                                                        *
*          A4 = UPPER LEFT Y,X                                           *
*          A5 = LOWER RIGHT Y,X                                          *
*          A6 = NUMBER OF SLICES GOING IN.                               *
*                                                                        *
**************************************************************************
G_BORDER: 
	MMTM    SP,A0,A1,A2,A3,A4,A5,A6
        MOVI    10001H,A0                 ;1 BY 1 DIMENSION

        MOVI    LAST_BORDER_COLOR,A9      ;USE LAST ONE 1ST
NEXT_RING:
        CALLR   DOBORDER                  ;DO THIS RING

        MOVI    10001H,A1                  ;THIS IS 1 UNIT IN X AND Y
        ADDXY   A1,A4
        SUBXY   A1,A5

        SUBI    101H,A9
        CMPI    FIRST_BORDER_COLOR,A9
        JRHS    COLOK
        MOVI    LAST_BORDER_COLOR,A9

COLOK:    
	DSJS    A6,NEXT_RING
	MMFM    SP,A0,A1,A2,A3,A4,A5,A6
	RETS

**************************************************************************
*                                                                        *
*          DOBORDER                                                      *
*                                                                        *
*          THIS IS CALLED TO DRAW A BORDER FRAME.                        *
*                                                                        *
*          A4 = UPPER LEFT Y,X                                           *
*          A5 = LOWER RIGHT Y,X                                          *
*          A0 = Y,X WIDTH OF BORDER                                      *
*          A9 = COLOR OF BORDER.                                         *
*                                                                        *
*          THIS ROUTINE *** CLEARS OUT ALL AREA INSIDE THE BORDER***     *
*          AS A FUNCTION OF ITS OPERATION.                               *
*                                                                        *
*          THE BORDER IS DONE IN THE "ROBO" PALETTE                     *
*                                                                        *
*          IT IS ASSUMED THAT THE DISPLAY SYSTEM IS RUNNING!             *
*                                                                        *
**************************************************************************
*
* A1 = <COLOR><PALETTE>
* A3 = DAG OF AREA [YPOS,XPOS]						 
* A4 = [Y,X] SIZE OF AREA						 
*
DOBORDER:
        MMTM    SP,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9
        MOVE    A9,A1                     ;GET COLOR
        SLL     16,A1                     ;COLOR ON TOP..PALETTE 0
*
*       NOW WE NEED TO MAKE 4 BARS!
*
        MOVE    A0,A2                     ;SEPARATE DELTA
        ANDI    SX_MASK,A0
        ANDI    SY_MASK,A2

        MOVE    A4,A6                     ;UPPER LEFTS HERE
        MOVE    A4,A7

        MOVE    A5,A8                     ;LOWER RIGHTS HERE
        MOVE    A5,A9

        ANDI    SX_MASK,A6                 ;LEFT X
        ANDI    SX_MASK,A8                 ;RIGHT X

        ANDI    SY_MASK,A7                 ;TOP Y
        ANDI    SY_MASK,A9                 ;BOTTOM Y

*
*       FIRST BAR GOES FROM ORIGINAL UL XY TO RIGHT X
*       AND TOP Y+DELTA Y
*
*       A3 IS ORIGINAL A4 PASSED.
*       FORM DESTINATION IN A4
*
        MOVE    A4,A3

        MOVX    A8,A4
        MOVY    A7,A4
        ADDXY   A2,A4                     ;ADD THE DELTA

        CALLR   DO_A_LINE                 ;DO THIS LINE
*
*       GOING AROUND CLOCKWISE.....THIS ONE STARTS AT RIGHT X-DELTA
*       AND TOP Y
*
        MOVX    A8,A3
        SUBXY   A0,A3
        MOVY    A7,A3
*
*       THIS IS THE NATURAL LOWER RIGHT CORNER
*
        MOVX    A8,A4
        MOVY    A9,A4

        CALLR   DO_A_LINE
*
*       NOW FOR BOTTOM LINE.....A4 IS STILL SET!
*
        MOVX    A6,A3
        MOVY    A9,A3
        SUBXY   A2,A3

        CALLR   DO_A_LINE
*
*       LEFT WALL....FROM UPPER LEFT
*
        MOVX    A6,A3
        MOVY    A7,A3

        MOVX    A6,A4
        ADDXY   A0,A4
        MOVY    A9,A4

        CALLR   DO_A_LINE

	MMFM    SP,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9
	RETS

DO_A_LINE:
        MMTM    SP,A4
        SUBXY   A3,A4           ;FORM DISTANCE
        CALLA   FILLAREA        ;AND DO THE FILL
	MMFM    SP,A4
	RETS

STD_BORD: 
	MMTM    SP,A0
        MOVI    BORDER_SIZE,A0
        CALLA   DOBORDER
	MMFM    SP,A0
	RETS
**************************************************************************
*                                                                        *
*          DO_HELP_MENU                                                  *
*                                                                        *
*          THIS IS CALLED TO DISPLAY A HELP MENU FOR THE CURRENT         *
*          MENU ENTRY.                                                   *
*                                                                        *
*          A HELP MENU IS DEFINED AS FOLLOWS:                            *
*                                                                        *
*          HM_JUST         WORD    0=CENTER   1=LEFT                     *
*          HM_COLOR        WORD    COLOR OF MENU                         *
*          HM_ENTS         WORD    NUMBER OF LINES IN MENU               *
*                          LONG    LONG WORD POINTERS FOR EACH LINE!     *
*                                                                        *
*          THE PROCESS AREA IS FILLED WITH THE CURRENT MENU              *
*          PARAMETERS.                                                   *
*                                                                        *
*          A8 = POINTER TO HELP MENU STRUCTURE ABOVE                     *
*                                                                        *
**************************************************************************
DO_HELP_MENU:
        CALLR   BLNKHELP

        MOVE    A8,A8                ;CHECK IF HELP MENU EXISTS.
        JRZ     DHMX                 ;NOPE JUST CLEARING WAS OUR JOB.
 
        MOVE    *A13(MEN_CUR),A0,W   ;THIS IS CURRENT ENTRY
        MOVE    A0,A11               ;PASS ENTRY NUMBER IN A11
        CALLR   GET_ENTRY_Y          ;A5 HAS THE Y FOR THE CURRENT ENTRY
*
*       NOW WE NEED TO MOVE TO MAKE TOP ENTRY BOX LINE UP.
*
        MOVE    *A13(MEN_BDY),A10,W  ;THIS IS NEGATIVE TO GIVE US BOX TOP
        ADD     A5,A10               ;NOW WE HAVE BOX TOP

        MOVE    *A13(MEN_BAR),A5,W   ;GET BAR HEIGHT
        SRL     1,A5                 ;FIND CENTER OF BAR
        ADD     A5,A10               ;NOW WE'RE AT BAR CENTER.

        MOVI    H_SLAVE,A7        ;FORK OFF SO IT CAN USE PDATA!
        CALLA   P_FORK               ;START UP ANOTHER W/ SAME ID TO FLASH!
DHMX    RETS

**************************************************************************
*                                                                        *
*          BLNKHELP                                                      *
*                                                                        *
*          THIS IS CALLED TO BLANK OUT THE HELP AREA.  IT IS             *
*          USED BY BOTH THE "NORMAL" HELP PLOTTER AND IS                 *
*          CALLED BY THE ADJUSTMENT HELP PROGRAM.                        *
*                                                                        *
*          THIS RETURNS THE LEFT X FOR THE HELP MENU IN A9               *
*                                                                        *
**************************************************************************
BLNKHELP:
        MMTM    SP,A3,A4,A5,A6
        CALLR   MENU_LR_A6_A5        ;GET RIGHT X OF MAIN MENU IN A6
        MOVE    A6,A9                ;PASS TO HELP MENU SLAVE
*
*       NOW BLANK OUT THE "HELP" REGION
*
        MOVE    A6,A3                ;UPPER LEFT X OF REGION TO BLANK OUT
        ADDI    INST_ULY*10000H,A3   ;THIS IS UPPER LEFT OF BLOCK

        MOVI    TIT_LRX+(10000H*400),A4 ;COORDINATE OF LOWER RIGHT OF HELP AREA
        SUBXY   A3,A4                   ;THIS IS SIZE OF REGION TO BLANK
        CALLA   BLNKAREA                ;BLANK OUT THE HELP AREA
        ADDI    BOX_XGAP,A9             ;RETURN X FOR HELP MENUS
	MMFM    SP,A3,A4,A5,A6
	RETS

**************************************************************************
*                                                                        *
*          H_SLAVE                                                       *
*                                                                        *
*          THIS IS A PROCESS CREATED TO PLOT THE HELP BOX.               *
*          IT DOES ITS PLOTTING THEN DIES.   THIS ALLOWS IT              *
*          TO USE THE PDATA AREA WITHOUT DISTURBING THE CALLER.          *
*                                                                        *
*          A8 = POINTER TO HELP BOX STRUCTURE                            *
*          A9 = LEFT MARGIN FOR THE HELP BOX.                            *
*          A10 = Y OF CENTER OF BOX ...HIGH HALF IS ZERO FOR Y CENTING   *
*                IF HIGH HALF IS NON-ZERO, THEN THIS IS TOP OF BOX       *
*                                                                        *
**************************************************************************
HM_JUST          EQU     0
HM_COLOR         EQU     HM_JUST+WORD_SIZE
HM_ENTS          EQU     HM_COLOR+WORD_SIZE
HM_DATA          EQU     HM_ENTS+WORD_SIZE      ;ENTRY POINTERS

HS_ROUT          EQU     PDATA             ;LONG-TEXT ROUTINE
HS_X             EQU     HS_ROUT+LONG_SIZE ;WORD-X FOR TEXT ROUTINE
HS_Y             EQU     HS_X+WORD_SIZE    ;WORD-CURRENT Y
HS_ENTS          EQU     HS_Y+WORD_SIZE    ;WORD-ENTRIES LEFT TO DO
HS_COLOR         EQU     HS_ENTS+WORD_SIZE ;WORD-COLOR OF MENU
HS_PTR           EQU     HS_COLOR+WORD_SIZE ;LONG-CURRENT TEXT POINTER

H_SLAVE:
*
*       A9 HAS RIGHT X OF MENU
*
        MOVE    A9,A1                     ;PUT THIS X VALUE IN A1

        MOVE    *A8(HM_JUST),A0,W         ;0 = CENTER  1=LEFT
        JRZ     HS_CENT                   ;CENTER....SETUP X ACCORDINGLY
*
*       LEFT JUSTIFY....STORE ROUTINE
*
        MOVI    STRLNRM,A0                ;LEFT JUSTIFY ROUTIN
*
*       NOW FORM X AS SOME MARGIN FROM WINDOW....
*
        ADDI    MB_XWID+HELP_X_MARGIN,A1  ;ADD MARGIN TO FORM X FOR TEXT
        JRUC    CENTER_JOIN               ;CONTINUE

HS_CENT:  
	MOVI    STRCNRM,A0                ;USE CENTERING ROUTINE
*
*       A1 HAS LEFT X OF HELP BOX...FIND RIGHT X
*
        ADDI    TIT_LRX,A1
        SRL     1,A1                      ;THIS IS CENTER X

CENTER_JOIN:
        MOVE    A1,*A13(HS_X),W           ;STORE X
        MOVE    A0,*A13(HS_ROUT),L        ;STORE ROUTINE

        MOVE    *A8(HM_ENTS),A1,W         ;GET NUMBER OF ENTRIES
        MOVE    A1,*A13(HS_ENTS),W        ;COUNT IT DOWN IN P-AREA

        MOVE    *A8(HM_COLOR),A0,W        ;GET COLOR
        MOVE    A0,*A13(HS_COLOR),W       ;STASH IT

        ADDI    HM_DATA,A8                ;POINT AT 1ST ENTRY
        MOVE    A8,*A13(HS_PTR),L         ;NOW WE'RE READY.
*
*       ALL PDATA AREA SET.....NOW WE NEED TO DRAW THE BORDER
*
*         FOR DOBORDER
*
*         A4 = UPPER LEFT Y,X                                           
*         A5 = LOWER RIGHT Y,X                                        
*         A0 = Y,X WIDTH OF BORDER                                     
*         A9 = COLOR OF BORDER.                                         
*
*       LOWER RIGHT X IS SUCH THAT IT LINES UP WITH TITLE BOX.
*       THE Y IS A BIT TRICKIER......NUMBER OF ENTRIES IS
*       SITTING IN A1
*
        MOVI    HELP_DY,A5                ;DISTANCE PER ENTRY
        MPYU    A1,A5                     ;DISTANCE FOR ALL ENTRIES
        ADDI    HELP_Y_MARGIN+(MB_YWID*2)+HELP_YLO_MARGIN,A5
*
*       A5 NOW CONTAINS FULL HEIGHT OF BOX
*
*       NOW SEE IF WE'RE CENTERING ON A10 OR IF A10 IS THE TOP.
*
        CALLR   TOP_IN_A10
*
*       NOW FORM UPPER LEFT IN A4
*
        MOVE    A10,A4                    ;MOVE Y OVER
        SLL     16,A4                     ;MAKE ROOM FOR X
        ADD     A9,A4                     ;PUT IN THE X...THIS IS UPPER LEFT!

        ADD     A10,A5                    ;ADD BASE TO OFFSET
        SLL     16,A5                     ;PUT IN Y POSITION
        ADDI    TIT_LRX,A5                ;ADD IN THE X FOR THE CORNER
*
*       NOW ADJUST FROM TOP OF BOX TO POSITION OF 
*       1ST ENTRY.
*
        ADDI    MB_YWID+HELP_Y_MARGIN,A10  ;Y OF 1ST ENTRY
        MOVE    A10,*A13(HS_Y),W           ;PUT AWAY

        MOVE    *A13(HS_COLOR),A9,W       ;GET THE COLOR FOR DOBORDER

        CALLR   STD_BORD       
*
*       NOW WE NEED TO WALK THROUGH AND PLOT THE HELP
*       MENU ENTRIES.
*
*       A0 = SLEEP
*       A1 = ROUTINE
*       A6 = COLOR
*       A8 = POINTER
*       A9 = ADDRESS
*       A10 = SPACING
*       A11 = FONT
*       A14 = FLAGS
*
NEXT_HELP:
        MOVE    *A13(HS_PTR),A2,L         ;GET OUR CURRENT POINTER
        MOVE    *A2+,A8,L                 ;GET THE CURRENT MESSAGE POINTER
        MOVE    A2,*A13(HS_PTR),L         ;AND PUT POINTER BACK

        CLR     A0
        MOVE    *A13(HS_ROUT),A1,L        ;ROUTINE IN A1
        MOVE    *A13(HS_COLOR),A6,W       ;STUFF COLOR

        MOVE    *A13(HS_Y),A9,W           ;GET Y
        SLL     16,A9                     ;SHIFT INTO PLACE
        MOVE    *A13(HS_X),A10,W
        ADD     A10,A9                    ;A9 IS NOW POINTING AT SCREEN

        MOVI    SPACING07,A10             ;SPACING
        MOVI    RD7FONT,A11               ;FONT IS BABY FONT
        JSRP    LM_FINIS                  ;PRINT IT OUT!

        MOVE    *A13(HS_Y),A9,W           ;GET THE Y
        ADDI    HELP_DY,A9                ;KICK IT
        MOVE    A9,*A13(HS_Y),W           ;PUT IT BACK

        MOVE    *A13(HS_ENTS),A0,W        ;ENTRY COUNT
        DEC     A0
        MOVE    A0,*A13(HS_ENTS),W        ;PUT IT BACK
        JRNZ    NEXT_HELP

        JAUC    SUCIDE                    ;OUR WORK IS DONE!

**************************************************************************
*                                                                        *
*          TOP_IN_A10                                                    *
*                                                                        *
*          THIS IS CALLED BY H_SLAVE TO GET THE UPPER LEFT               *
*          CORNER OF THE BOX IN A10.  A10 HAS THE PASSED PARAMETER.      *
*          A5 HAS THE HEIGHT OF THE BOX.  IF THE TOP HALF OF A10         *
*          IS ZERO, THEN THEN WE WANT THE BOX CENTER AT THE              *
*          A10 LEVEL.  IF THE TOP HALF OF A10 IS NON-ZERO THEN           *
*          A10 WAS PASSED AS THE TOP.                                    *
*                                                                        *
*          RETURN A10 AS THE Y FOR THE TOP OF THE HELP BOX.              *
*                                                                        *
**************************************************************************
TOP_IN_A10:
        MMTM    SP,A5
        CMPI    0FFFFH,A10                ;IS THE TOP HALF ZERO?
        JRHI    TOP_IS_TOP                ;TOP IS SET..RETURN
        SRL     1,A5                      ;TOP OF BOX IS HALF UP FROM MAIN MENU BAR CENTER
        SUB     A5,A10                    ;NOW A10 HAS Y BASE OF BOX
TOP_IS_TOP:
	MMFM    SP,A5
	RETS

**************************************************************************
*                                                                        *
*          AREUSURE                                                      *
*                                                                        *
*          THIS IS CALLED TO GET A CONFIRMATION FROM THE USER.           *
*          A8 = PROMPT...THIS WILL APPEAR ABOVE THE "ARE YOU SURE"       *
*          A9 = ROUTINE TO JSRP TO DO THE DESIRED ACTION                 *
*          A10 = MESSAGE TO DISPLAY CONFIRMING COMPLETION                *
*                                                                        *
*          RETURN A0=0 MEANS YES WAS CHOSEN.                             *
*                 A0 .NE. 0 MEANS NO                                     *
*                                                                        *
**************************************************************************
AREUSURE:
        CALLA   CLR_SCRN             ;BLANK IT ALL OUT!
        MOVE    A9,*A13(PDATA),L     ;SAVE ROUTINE
        MOVE    A10,-*A12,L          ;AND CONFIRM MESSAGE

        CALLR   SURE_BOX

        MOVE    A8,A2                ;PUT MESSAGE TEXT IN SAFE PLACE
        MOVI    MESS_SURE,A8         ;SETUP FOR TITLE
        CALLA   LM_SETUP             ;STUFF REGGIES
        MOVE    A2,A8                ;GET STRING IN THERE
        JSRP    LM_FINIS             ;AND PRINT IT

        MOVI    M_SURE,A8            ;NOW THE "ARE YOU SURE" PART
        JSRP    L_MESS               ;PUT IT UP.

        MOVI    MEN_YN,A8            ;PUT UP THE "YES/NO" SELECTOR.
        MOVI    2,A9                 ;CURSOR ON 2ND ENTRY (NO)

        JSRP    B_MENU               ;AND GET A RESPONSE.
        CMPI    1,A8                 ;WAS IT YES?
        JRNZ    SURE_X               ;NOPE....GET OUT

        CALLA   CLR_SCRN             ;CLEAR THE SCREEN FIRST, SO ROUTINE CAN PLOT!

        MOVE    *A13(PDATA),A0,L     ;GET THE ROUTINE TO CALL
        MOVI    SURE_RET,A7
        MOVE    A7,-*A12,L           ;PUSH RETURN ADDRESS
        JUMP    A0                   ;AND "JSRP" THE ROUTINE

SURE_RET: 
	CALLR   SURE_BOX             ;BOX IT!
        MOVE    *A12+,A8,L
        JSRP    SUR_MESS             ;PRINT THE MESSAGE

        JSRP    ANY_BUT              ;NOW RETRIEVE ANY BUTTON THEN RETURN

        CLR     A0                   ;RETURN SUCCESS
        RETP

SURE_X:   
	ADDI    LONG_SIZE,A12        ;POP MESSAGE
        MOVI    2,A0                 ;RETURN FAILURE
        RETP

**************************************************************************
*                                                                        *
*          SUR_MESS                                                      *
*                                                                        *
*          THIS PRINTS MESSAGE IN A8 IN THE ARE U SURE BOX               *
*          CONFIRMATION SPOT.                                            *
*                                                                        *
**************************************************************************
SUR_MESS:
        MOVE    A8,-*A12,L
        MOVI    MESS_CONFIRM,A8
        CALLA   LM_SETUP             ;GET CONFIRMATION DATA READY.
        MOVE    *A12+,A8,L
        JSRP    LM_FINIS             ;PRINT OUR PART
        RETP

SURE_BOX:
        MOVI    ROBO_ORANGE,A9
        MOVI    003D0025H,A4
        MOVI    00F6016AH,A5
        CALLR   STD_BORD            ;BORDER-IZE THE WHOLE THING.
        RETS

CENT_BOX:
        MOVI    ROBO_RED,A9
CBOX_COL:
        MOVI    00450025H,A4
        MOVI    00B4016AH,A5
        CALLR   STD_BORD            ;BORDER-IZE THE WHOLE THING.
        RETS

*
*INTERFACE TO DIAGNOSTICS
DIAGADDR .EQU	0FFF77000H	;FIXED ADDRESS FOR DIAGNOSTIC ROUTINES
*JUMP TABLE VECTORS
ROMTEST	.EQU	DIAGADDR	
CPUTEST	.EQU	DIAGADDR+30H
SWTEST	.EQU	DIAGADDR+60H
COLORBR	.EQU	DIAGADDR+90H
CROSSHCH .EQU	DIAGADDR+0C0H
COPYSCRN .EQU	DIAGADDR+0F0H
BURNINT	.EQU	DIAGADDR+120H
PWRONTST .EQU	DIAGADDR+150H

*
*DO ROM TEST
ROM_CHK:
	MMTM	SP,A12,A13
	CALLR	CHECKROM
	MMFM	SP,A12,A13
	RETS
*
*DO SWITCH TEST
SW_CHK:
	MMTM	SP,A12,A13
	CALLR	CHECKSW
	MMFM	SP,A12,A13
	RETS
*
*PUT UP THE COLOR BARS
COL_BARS:
	MMTM	SP,A12,A13
	CALLR	COLORBARS
	MMFM	SP,A12,A13
	RETS
*
*PUT UP THE CROSS HATCH PATTERN
CROSS_H:
	MMTM	SP,A12,A13
	CALLR	CROSSHATCH
	MMFM	SP,A12,A13
	RETS

*
*JUMP TO THE SYSTEM BURN-IN TEST
BURN_IN:
	DINT
	CALLR	WDOGDIS			;NO DOGGIES
	JAUC	BURNINT

*
*DO CPU TEST, RETURNS TO CPUTESTR
CPU_CHK:
	DINT
	CALLR	WDOGDIS
	JAUC	CPUTEST
*
*CPU TEST RETURN POINT
CPUTESTR:
	MOVI	RT_RET,B0
	JRUC	BTESTR
*ROM BOARD TEST RETURN POINT
ROMTESTR:
	MOVI	ROM_RET,B0
BTESTR:
	MOVI	DIAG_PID,A1
	CALLA	GETPRC			;CREATE PROCESS FOR RETURN
	MOVI	INAMODE,A0
	MOVE	A0,@GAMSTATE,W
	JAUC	WARMSET
*
*CHECK THE ROM BOARD, THIS IS THE ONLY PLACE TO CALL ROMTEST
*NO REGISTERS ARE PRESERVED
CHECKROM:
	PUSHST
	DINT
	MOVE	SP,@SPTEMP,L
	CALLR	WDOGDIS
	JAUC	ROMTEST
*
*CHECK THE ROM SWITCHES, THIS IS THE ONLY PLACE TO CALL SWTEST
*NO REGISTERS ARE PRESERVED
CHECKSW:
	PUSHST
	DINT
	MOVE	SP,@SPTEMP,L
	CALLR	WDOGDIS
	JAUC	SWTEST
SWTESTR:
	SETF	16,1,0	;WORD SIGN EXTEND
	SETF	32,1,1	;LONG WORD
	MOVE	@SPTEMP,SP,L
	POPST
	RETS

*
*PUT UP CONVERGENCE PATTERN, THIS IS THE ONLY PLACE TO CALL CROSSHCH
*NO REGISTERS ARE PRESERVED
CROSSHATCH:
	PUSHST
	DINT
	MOVE	SP,@SPTEMP,L
	CALLR	WDOGDIS
	JAUC	CROSSHCH
CROSSHCHR:
	SETF	16,1,0	;WORD SIGN EXTEND
	SETF	32,1,1	;LONG WORD
	MOVE	@SPTEMP,SP,L
	POPST
	RETS
*
*PUT UP COLOR BARS, THIS IS THE ONLY PLACE TO CALL COLORBR
*NO REGISTERS ARE PRESERVED
COLORBARS:
	PUSHST
	DINT
	MOVE	SP,@SPTEMP,L
	CALLR	WDOGDIS
	JAUC	COLORBR
COLORBRR
	SETF	16,1,0	;WORD SIGN EXTEND
	SETF	32,1,1	;LONG WORD
	MOVE	@SPTEMP,SP,L
	POPST
	RETS

*----------------------------------------------------------------------------*
*----------------------------------------------------------------------------*
*****************************    MESSAGES    *********************************
*----------------------------------------------------------------------------*
*----------------------------------------------------------------------------*

INSTR_Y  EQU     INST_ULY+5
INSTR_2Y EQU     INSTR_Y+10

MM_INST1
         MESS_MAC  RD7FONT,SPACING07,MENU_X,INSTR_Y,ROBO_CYAN,STRCNRM,0
         .STRING   "SELECT WITH ANY STICK"
         .BYTE   0  
         .EVEN

MM_INST2
         MESS_MAC  RD7FONT,SPACING07,MENU_X,INSTR_2Y,ROBO_CYAN,STRCNRM,0
         .STRING   "ACTIVATE WITH ANY BUTTON"
         .BYTE   0 
         .EVEN

MESS_DOOR
         MESS_MAC  RD7FONT,SPACING20,200,128,ROBO_RED,STRCNRM,0
         .STRING  "INVALID GAME SETTINGS"
         .BYTE   0,1                  ;0 = END OF STRING...1 = MORE MESSAGES!
         .EVEN
MESS_OPEN
         MESS_MAC  RD7FONT,SPACING20,200,160,ROBO_WHITE,STRCNRM,0
         .STRING  "OPEN COIN DOOR TO"
         .BYTE   0,1                  ;0 = END OF STRING...1 = MORE MESSAGES!
         .EVEN
MESS_OPEN_2
         MESS_MAC  RD7FONT,SPACING20,200,179,ROBO_WHITE,STRCNRM,0
         .STRING  "RESTORE FACTORY SETTINGS."
         .BYTE    0,0
         .EVEN

MESS_FAIL
         MESS_MAC  RD7FONT,SPACING20,200,112,ROBO_RED,STRCNRM,0
         .STRING  "INVALID GAME SETTINGS"
         .BYTE   0,1                  ;0 = END OF STRING...1 = MORE MESSAGES!
         .EVEN
         MESS_MAC  RD7FONT,SPACING20,200,144,ROBO_WHITE,STRCNRM,0
         .STRING  "ATTEMPT TO RESTORE"
         .BYTE   0,1                  ;0 = END OF STRING...1 = MORE MESSAGES!
         .EVEN
         MESS_MAC  RD7FONT,SPACING20,200,164,ROBO_WHITE,STRCNRM,0
         .STRING  "FACTORY SETTINGS HAS FAILED."
         .BYTE    0,0
         .EVEN

MESS_BITCHIN
         .STRING "ADJUSTMENTS OK"
         .BYTE   0
         .EVEN

MESS_TITLE
         MESS_MAC  RD7FONT,SPACING20,TM_X,TM_Y,ROBO_GREEN,STRCNRM,0

RV_Y     EQU     TM_Y+16

MESS_REV
         MESS_MAC  RD7FONT,SPACING20,TM_X,RV_Y,ROBO_YELLOW,STRCNRM,0
*
*        THIS IS SETUP FOR THE QUESTION BEING ASKED
*        BY "ARE YOU SURE"
*
MESS_SURE
         MESS_MAC  RD7FONT,SPACING20,200,102,ROBO_LF,STRCNRM,0
*
*        THIS IS THE "ARE YOU SURE" PART.
*
M_SURE
         MESS_MAC  RD7FONT,SPACING20,200,128,ROBO_YELLOW,STRCNRM,0
         .STRING   "ARE YOU SURE?"
         .BYTE      0,0
         .EVEN

MESS_CONFIRM
         MESS_MAC  RD7FONT,SPACING20,200,115,ROBO_LF,STRCNRM,0

SIY1     EQU     SND_MESS_Y+28
SIY3     EQU     SND_MESS_Y+37
SIY2     EQU     SND_MESS_Y+11

SND_INST
          MESS_MAC  RD7FONT,SPACING07,200,SIY1,ROBO_WHITE,STRCNRM,0
         .STRING   "PRESS START BUTTON TO REPEAT."
         .BYTE     0,1
         .EVEN
          MESS_MAC  RD7FONT,SPACING07,200,SIY3,ROBO_WHITE,STRCNRM,0
         .STRING   "ANY OTHER BUTTON FOR NEXT SELECTION."
         .BYTE     0,0
         .EVEN

SND_SETUP MESS_MAC  RD7FONT,SPACING20,200,SIY2,ROBO_WHITE,STRCNRM,0

STABLE   .LONG   ST1
         .LONG   ST2
         .LONG   ST3
         .LONG   ST4
         .LONG   ST5
         .LONG   ST6
         .LONG   ST7
         .LONG   ST8
         .LONG   ST9
         .LONG   ST10
         .LONG   ST11
         .LONG   ST12

DTABLE   .LONG   DT1
         .LONG   DT2
         .LONG   DT3
         .LONG   DT4
         .LONG   DT5
         .LONG   DT6
         .LONG   DT7
         .LONG   DT8
         .LONG   DT9

ST1      .STRING "NARC RAP"
         .BYTE 0
         .EVEN
ST2      .STRING "DRIVING MUSIC"
         .BYTE 0
         .EVEN
ST3      .STRING "NARC THEME"
         .BYTE 0
         .EVEN
ST4      .STRING "THE "
         .BYTE ASCII_DQ
         .STRING "STICK"
         .BYTE FONT_RQUOTE
         .BYTE 0
         .EVEN
ST5      .STRING "HELICOPTER"
         .BYTE 0
         .EVEN
ST6      .STRING "KINKY PINKY"
         .BYTE 0
         .EVEN
ST7      .STRING "WINDSHIELD SMASH"
         .BYTE 0
         .EVEN
ST8      .STRING "CAR HORN"
         .BYTE 0
         .EVEN
ST9      .STRING "BUG SQUASH"
         .BYTE 0
         .EVEN
ST10      .STRING "SIZZLE"
         .BYTE 0
         .EVEN
ST11     .STRING "U10 - DAC   RAMP WAVE"
         .BYTE 0
         .EVEN
ST12     .STRING "U7/U8 - YM2151 SINE WAVE"
         .BYTE 0
         .EVEN

DT1      .STRING "GUNSHOT"
         .BYTE 0
         .EVEN
DT2      .STRING "DUMPSTER MAN"
         .BYTE 0
         .EVEN
DT3      .STRING "OH NO, THE ROBO MAN!"
         .BYTE 0
         .EVEN
DT4      .STRING "DRJ. SCREAM"
         .BYTE 0
         .EVEN
DT5      .STRING "DOG"
         .BYTE 0
         .EVEN
DT6      .STRING "YOU DIE COP!"
         .BYTE 0
         .EVEN
DT7      .STRING "MR. BIG LAUGH"
         .BYTE 0
         .EVEN
DT8      .STRING "U20 - DAC RAMP WAVE"
         .BYTE 0
         .EVEN
DT9      .STRING "U30 - CVSD WAVEFORM"
         .BYTE 0
         .EVEN

