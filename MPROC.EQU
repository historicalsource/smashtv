*******************
*MASTER EQUATE FILE
*******************
*
*GLOBAL VARIABLES
*
	.GLOBL	KILALL,GETPRC,KILL,PINIT,SUCIDE,PRCSLP,PRCDSP,PRCLSP,EXISTP
	.GLOBL	RAND,TIMER,OVERLOAD,ACTIVE,FREE,PRCSTR
	.GLOBL	SNDRES,SNDRESP,ONESND,SNDLD,SNDSND,CKSNDPRI,QSNDRST
	.GLOBL	GETA11,GETA10,GETA9,GETA8,XFERPROC
	.GLOBL	PUTA11,PUTA10,PUTA9,PUTA8,PUTA7

*
* PROCESS DATA STRUCTURE
* NOTE: MAKE SURE THIS IS EVENLY DIVISIBLE BY 32
*
*STRUCT PROC
PLINK	.SET    0	        ;LINK TO NEXT 32 BITS
PROCID	.SET	20H	        ;UHW PROCESS ID 16 BITS
PTIME	.SET    30H	        ;UHW SLEEP TIME X 16MSEC 16 BITS
PSPTR	.SET    40H	        ;UHL PROCESS STACK POINTER 32 BITS
PA11	.SET	60H		;UHL	REGISTERS SAVED
PA10	.SET	80H		;UHL
PA9	.SET    0A0H		;UHL
PA8	.SET	0C0H		;UHL
PWAKE	.SET	0E0H		;UHL
PDATA	.SET    100H	        ;PROCESS DATA STORE
PSDATA	.SET    2A0H            ;PROCESS STACK DATA (PC, A8-A11)
PRCSIZ	.SET    5A0H            ;END OF DATA STRUCTURE
*ENDSTRUCT

NPROC	.SET    240	        ;NUMBER OF PROCESSES ;168 ;198


*
*GSP MACROS
*
*
*SUBTRACT REGISTER FROM MEMORY
*	SUBRM	REG,ADDR,FIELD SIZE
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
SUBRM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	SUB	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$END
*
*ADD REGISTER TO MEMORY
*	ADDRM	REG,ADDR,FIELD SIZE
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
ADDRM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	ADD	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$END

*INCREMENT LOCATION
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
**
INCW	$MACRO	P1
	MOVE	:P1:,A14
	INC	A14
	MOVE	A14,:P1:
	$END

*
*DECREMENT WORD
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
**
DECW	$MACRO	P1
	MOVE	:P1:,A14
	DEC	A14
	MOVE	A14,:P1:
	$END

*
*INCREMENT MEMORY
*	INCM	ADDR,FIELD SIZE
*A14 DESTROYED
**
INCM	$MACRO	P1,P2
	MOVE	:P1:,A14,:P2:
	INC	A14
	MOVE	A14,:P1:,:P2:
	$END

*
*DECREMENT MEMORY
*	DECM	ADDR,FIELD SIZE
*A14 DESTROYED
**
DECM	$MACRO	P1,P2
	MOVE	:P1:,A14,:P2:
	DEC	A14
	MOVE	A14,:P1:,:P2:
	$END

*
*SUBTRACT MEMORY
*	SUBM	ADDR,REG,FIELD SIZE
*SUBTRACTS ADDRESS FROM REGISTER
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
SUBM	$MACRO	P1,P2,P3
	MOVE	:P1:,A14,:P3:
	SUB	A14,:P2:
	$END
*
*ADD MEMORY
*	ADDM	ADDR,REG,FIELD SIZE
*ADDS ADDRESS FROM REGISTER
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
ADDM	$MACRO	P1,P2,P3
	MOVE	:P1:,A14,:P3:
	ADD	A14,:P2:
	$END
*
*NEGATE MEMORY
*	NEGM	ADDR,FIELD SIZE
*NEGATES ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
NEGM	$MACRO	P1,P2
	MOVE	:P1:,A14,:P2:
	NEG	A14
	MOVE	A14,:P1:,:P2:
	$END
*
*COMPARE MEMORY
*	CMPM	ADDR,REG,FIELD SIZE
*COMPARES ADDRESS TO REGISTER
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
CMPM	$MACRO	P1,P2,P3
	MOVE	:P1:,A14,:P3:
	CMP	A14,:P2:
	$END
*
*CLEAR MEMORY
*	CLRM	ADDR,FIELD SIZE
*CLEARS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
CLRM	$MACRO	P1,P2
	CLR	A14
	MOVE	A14,:P1:,:P2:
	$END
*
*COMPLEMENT MEMORY
*	COMM	ADDR,FIELD SIZE
*COMPLEMENTS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
COMM	$MACRO	P1,P2
	MOVE	:P1:,A14,:P2:
	NOT	A14
	MOVE	A14,:P1:,:P2:
	$END
*
*SHIFT LEFT MEMORY
*	SLLM	SHIFT COUNT,ADDR,FIELD SIZE
*SHIFTS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
SLLM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	SLL	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$END
*
*SHIFT RIGHT ARITHMETIC MEMORY
*	SRAM	SHIFT COUNT,ADDR,FIELD SIZE
*SHIFTS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
SRAM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	SEXT	A14,:P3:
	SRA	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$END
*
*SHIFT RIGHT LOGICAL MEMORY
*	SRLM	SHIFT COUNT,ADDR,FIELD SIZE
*SHIFTS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
SRLM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	ZEXT 	A14,:P3:
	SRL	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$END

*
*BIT SET
*	BSET	BIT# 0-31(KONSTANT OR REGISTER),REGISTER TO SET BIT IN
* NOTE: A14 IS DESTROYED, 'A' FILE REGISTERS ONLY
*
BSET	$MACRO	P1,R1
	MOVK	1,A14
	SLL	:P1:,A14
	OR	A14,:R1:
	$END

*
*BIT CLR
*	BCLR	BIT# 0-31(KONSTANT OR REGISTER),REGISTER TO CLR BIT IN
* NOTE: A14 IS DESTROYED, 'A' FILE REGISTERS ONLY
*
BCLR	$MACRO	P1,R1
	MOVK	1,A14
	SLL	:P1:,A14
	ANDN	A14,:R1:
	$END

*
*SET THE Z BIT
*	SETZ
* STATUS BITS:
*		N Unaffected
*		C Unaffected
*		Z 1
*		V Unaffected
* NOTE: A14 IS CLEARED
*
SETZ	$MACRO
	CLR	A14
	$END

*
*CLR THE Z BIT
*	CLRZ
* STATUS BITS:
*		N Unaffected
*		C Unaffected
*		Z 0
*		V Unaffected
* NOTE: A14 IS SET TO 1
*
CLRZ	$MACRO
	CLR	A14
	NOT	A14
	$END

*
*PROCESS SLEEP CONSTANT
*P1=SLEEP TIME CONSTANT 1-FFFF LOADED INTO A0
*RET ADDR ON STACK
*
SLEEP	$MACRO	P1
	$IF	P1 < 33
	MOVK	:P1:,A0
	$ELSE	
	MOVI	:P1:,A0
	$ENDIF
	CALLA	PRCSLP
	$END
*
*PROCESS SLEEP REGISTER
*REG1=REGISTER THAT CONTAINS SLEEP TIME 1-FFFF LOADED INTO A0
*RET ADDR ON STACK
*
SLEEPR	$MACRO	REG1
	MOVE	:REG1:,A0
	CALLA	PRCSLP
	$END

*
*PROCESS LOOP SLEEP
*P1=SLEEP TIME -->A0, P2 =WAKEUP ADDR-->A7
*
SLOOP	$MACRO	P1,P2
	$IF	P1 < 33
	MOVK	:P1:,A0
	$ELSE	
	MOVI	:P1:,A0
	$ENDIF
	MOVI	:P2:,A7,L
	JAUC	PRCLSP
	$END
	
*
*PROCESS LOOP SLEEP REGISTER
*P1=REGISTER CONTAINING SLEEP TIME 1-FFFF, P2 =WAKEUP ADDR-->A7
*
SLOOPR	$MACRO	P1,P2
	MOVE	:P1:,A0
	MOVI	:P2:,A7,L
	JAUC	PRCLSP
	$END

*
*PROCESS CREATION MACRO
*P1=ID-->A1, P2=PC-->A7
*
CREATE	$MACRO	P1,P2
 	MOVI	:P1:,A1
	MOVI	:P2:,A7,L
	CALLA	GETPRC
	$END

*
*KILL PROCESS(ES)
*P1=ID-->A0,P2=MASK-->A1
*
KILLIT	$MACRO	P1,P2
	MOVI	:P1:,A0
	MOVI	:P2:,A1
	CALLA	KILALL
	$END

*
*CALL IT QUITS
*
DIE	$MACRO
	JAUC	SUCIDE
	$END
*
*PROCESS JUMP SUBROUTINE
*P1=ADDRESS OF SLEEPING PROCESS
*A7 IS USED FOR PC STORAGE
*
JSRP	$MACRO	P1
	GETPC	A7
	ADDI    060h,A7
	MOVE	A7,-*A12,L	;PUSH RET ADDR
	JAUC	:P1:
	$END

*
*PROCESS JUMP SUBROUTINE ON REGISTER
*R1=REGISTER CONTAINING ADDRESS OF SLEEPING PROCESS
*A7 IS USED FOR PC STORAGE
*
JSRPR	$MACRO	R1
	GETPC	A7
	ADDI    040h,A7
	MOVE	A7,-*A12,L	;PUSH RET ADDR
	JUMP	:R1:
	$END

*
*RETURN FROM SLEEPING SUBROUTINE
*A7 IS USED FOR PC STORAGE
*STATUS REGISTER IS NOT AFFECTED
*	
RETP	$MACRO	
	MMFM	A12,A7		;PULL RETURN ADDR, W/O ZAPPING STAT
	EXGPC	A7
	$END

*FIND MATCHING PROCESS(ES), BRANCH IF ONE WAS FOUND
*P1=ID-->A0,P2=MASK-->A1,P3=BRANCH LABEL
MATCHP	$MACRO	P1,P2,P3
	MOVI	:P1:,A0
	MOVI	:P2:,A1
	CALLA	EXISTP
	JANZ	:P3:
	$END

*FIND MATCHING PROCESS(ES), BRANCH IF NONE WERE FOUND
*P1=ID-->A0,P2=MASK-->A1,P3=BRANCH LABEL
NOMATCHP $MACRO	P1,P2,P3
	 MOVI	:P1:,A0
	 MOVI	:P2:,A1
	 CALLA	EXISTP
	 JAZ	:P3:
	 $END

*PUSH REGISTER(S) ONTO THE STACK
*USAGE: ONE OPERAND -> PUSH OP   2 OR MORE OPS -> PUSH (OP1,OP2,...,OPN)
PUSH	$MACRO	REG
	MOVE :REG:,-*SP,1
	$END

*PULL REGISTER(S) OFF OF THE STACK
*USAGE: ONE REGISTER -> PULL REG   2 OR MORE REGS -> PULL (REG1,REG2,...,REGN)
PULL	$MACRO	REG
	MMFM	SP,:REG:
	$END

*PUSH REGISTER ONTO THE PROCESS STACK
*USAGE: ONE OPERAND -> PUSH REG
PUSHP	$MACRO	REG
	MOVE :REG:,-*A12,L
	$END

*PULL REGISTER(S) OFF OF THE PROCESS STACK
*USAGE: ONE REGISTER -> PULL REG 
PULLP	$MACRO	REG
	MMFM	A12,:REG:
	$END

*PUSH LOW WORD OF REGISTER ON TO STACK
*ONE REGISTER ONLY!
*USAGE: PUSHW REG
PUSHW	$MACRO	REG
	MOVE :REG:,-*SP,0
	$END

*PULL LOW WORD OF REGISTER OFF OF STACK
*ONE REGISTER ONLY!
*USAGE: PULLW REG
PULLW	$MACRO	REG
	MOVE *SP+,:REG:,0
	$END

*NULL LONG WORD							 
LONGNULL:$MACRO	 
	.LONG 0								 
	$END								 
*
*LOCKUP MACRO
*
LOCKUP	$MACRO
	DINT
	JRUC	$
	$END
